<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面向对象进阶</title>
      <link href="/2020/06/29/python/mian-xiang-dui-xiang-jin-jie/"/>
      <url>/2020/06/29/python/mian-xiang-dui-xiang-jin-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象进阶"><a href="#面向对象进阶" class="headerlink" title="面向对象进阶"></a>面向对象进阶</h2><p>在前面的章节我们已经了解了面向对象的入门知识，知道了如何定义类，如何创建对象以及如何给对象发消息。为了能够更好的使用面向对象编程思想进行程序开发，我们还需要对Python中的面向对象编程进行更为深入的了解。</p><h3 id="property装饰器"><a href="#property装饰器" class="headerlink" title="@property装饰器"></a>@property装饰器</h3><p>之前我们讨论过Python中属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示。</p><pre class=" language-Python"><code class="language-Python">class Person(object):    def __init__(self, name, age):        self._name = name        self._age = age    # 访问器 - getter方法    @property    def name(self):        return self._name    # 访问器 - getter方法    @property    def age(self):        return self._age    # 修改器 - setter方法    @age.setter    def age(self, age):        self._age = age    def play(self):        if self._age <= 16:            print('%s正在玩飞行棋.' % self._name)        else:            print('%s正在玩斗地主.' % self._name)def main():    person = Person('王大锤', 12)    person.play()    person.age = 22    person.play()    # person.name = '白元芳'  # AttributeError: can't set attributeif __name__ == '__main__':    main()</code></pre><h3 id="slots-魔法"><a href="#slots-魔法" class="headerlink" title="__slots__魔法"></a>__slots__魔法</h3><p>我们讲到这里，不知道大家是否已经意识到，Python是一门<a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">动态语言</a>。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。</p><pre class=" language-Python"><code class="language-Python">class Person(object):    # 限定Person对象只能绑定_name, _age和_gender属性    __slots__ = ('_name', '_age', '_gender')    def __init__(self, name, age):        self._name = name        self._age = age    @property    def name(self):        return self._name    @property    def age(self):        return self._age    @age.setter    def age(self, age):        self._age = age    def play(self):        if self._age <= 16:            print('%s正在玩飞行棋.' % self._name)        else:            print('%s正在玩斗地主.' % self._name)def main():    person = Person('王大锤', 22)    person.play()    person._gender = '男'    # AttributeError: 'Person' object has no attribute '_is_gay'    # person._is_gay = True</code></pre><h3 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h3><p>之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义一个“三角形”类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此我们可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。我们可以使用静态方法来解决这类问题，代码如下所示。</p><pre class=" language-Python"><code class="language-Python">from math import sqrtclass Triangle(object):    def __init__(self, a, b, c):        self._a = a        self._b = b        self._c = c    @staticmethod    def is_valid(a, b, c):        return a + b > c and b + c > a and a + c > b    def perimeter(self):        return self._a + self._b + self._c    def area(self):        half = self.perimeter() / 2        return sqrt(half * (half - self._a) *                    (half - self._b) * (half - self._c))def main():    a, b, c = 3, 4, 5    # 静态方法和类方法都是通过给类发消息来调用的    if Triangle.is_valid(a, b, c):        t = Triangle(a, b, c)        print(t.perimeter())        # 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数        # print(Triangle.perimeter(t))        print(t.area())        # print(Triangle.area(t))    else:        print('无法构成三角形.')if __name__ == '__main__':    main()</code></pre><p>和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象，代码如下所示。</p><pre class=" language-Python"><code class="language-Python">from time import time, localtime, sleepclass Clock(object):    """数字时钟"""    def __init__(self, hour=0, minute=0, second=0):        self._hour = hour        self._minute = minute        self._second = second    @classmethod    def now(cls):        ctime = localtime(time())        return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)    def run(self):        """走字"""        self._second += 1        if self._second == 60:            self._second = 0            self._minute += 1            if self._minute == 60:                self._minute = 0                self._hour += 1                if self._hour == 24:                    self._hour = 0    def show(self):        """显示时间"""        return '%02d:%02d:%02d' % \               (self._hour, self._minute, self._second)def main():    # 通过类方法创建对象并获取系统时间    clock = Clock.now()    while True:        print(clock.show())        sleep(1)        clock.run()if __name__ == '__main__':    main()</code></pre><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系。</p><ul><li>is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。</li><li>has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。</li><li>use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。</li></ul><p>我们可以使用一种叫做<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">UML</a>（统一建模语言）的东西来进行面向对象建模，其中一项重要的工作就是把类和类之间的关系用标准化的图形符号描述出来。关于UML我们在这里不做详细的介绍，有兴趣的读者可以自行阅读<a href="https://e.jd.com/30392949.html" target="_blank" rel="noopener">《UML面向对象设计基础》</a>一书。</p><p><img src="./res/uml-components.png" alt=""></p><p><img src="./res/uml-example.png" alt=""></p><p>利用类之间的这些关系，我们可以在已有类的基础上来完成某些操作，也可以在已有类的基础上创建新的类，这些都是实现代码复用的重要手段。复用现有的代码不仅可以减少开发的工作量，也有利于代码的管理和维护，这是我们在日常工作中都会使用到的技术手段。</p><h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3><p>刚才我们提到了，可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为<a href="https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">里氏替换原则</a>。下面我们先看一个继承的例子。</p><pre class=" language-Python"><code class="language-Python">class Person(object):    """人"""    def __init__(self, name, age):        self._name = name        self._age = age    @property    def name(self):        return self._name    @property    def age(self):        return self._age    @age.setter    def age(self, age):        self._age = age    def play(self):        print('%s正在愉快的玩耍.' % self._name)    def watch_av(self):        if self._age >= 18:            print('%s正在观看爱情动作片.' % self._name)        else:            print('%s只能观看《熊出没》.' % self._name)class Student(Person):    """学生"""    def __init__(self, name, age, grade):        super().__init__(name, age)        self._grade = grade    @property    def grade(self):        return self._grade    @grade.setter    def grade(self, grade):        self._grade = grade    def study(self, course):        print('%s的%s正在学习%s.' % (self._grade, self._name, course))class Teacher(Person):    """老师"""    def __init__(self, name, age, title):        super().__init__(name, age)        self._title = title    @property    def title(self):        return self._title    @title.setter    def title(self, title):        self._title = title    def teach(self, course):        print('%s%s正在讲%s.' % (self._name, self._title, course))def main():    stu = Student('王大锤', 15, '初三')    stu.study('数学')    stu.watch_av()    t = Teacher('骆昊', 38, '砖家')    t.teach('Python程序设计')    t.watch_av()if __name__ == '__main__':    main()</code></pre><p>子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。</p><pre class=" language-Python"><code class="language-Python">from abc import ABCMeta, abstractmethodclass Pet(object, metaclass=ABCMeta):    """宠物"""    def __init__(self, nickname):        self._nickname = nickname    @abstractmethod    def make_voice(self):        """发出声音"""        passclass Dog(Pet):    """狗"""    def make_voice(self):        print('%s: 汪汪汪...' % self._nickname)class Cat(Pet):    """猫"""    def make_voice(self):        print('%s: 喵...喵...' % self._nickname)def main():    pets = [Dog('旺财'), Cat('凯蒂'), Dog('大黄')]    for pet in pets:        pet.make_voice()if __name__ == '__main__':    main()</code></pre><p>在上面的代码中，我们将<code>Pet</code>类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过<code>abc</code>模块的<code>ABCMeta</code>元类和<code>abstractmethod</code>包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，<code>Dog</code>和<code>Cat</code>两个子类分别对<code>Pet</code>类中的<code>make_voice</code>抽象方法进行了重写并给出了不同的实现版本，当我们在<code>main</code>函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。</p><h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><h4 id="案例1：奥特曼打小怪兽。"><a href="#案例1：奥特曼打小怪兽。" class="headerlink" title="案例1：奥特曼打小怪兽。"></a>案例1：奥特曼打小怪兽。</h4><pre class=" language-Python"><code class="language-Python">from abc import ABCMeta, abstractmethodfrom random import randint, randrangeclass Fighter(object, metaclass=ABCMeta):    """战斗者"""    # 通过__slots__魔法限定对象可以绑定的成员变量    __slots__ = ('_name', '_hp')    def __init__(self, name, hp):        """初始化方法        :param name: 名字        :param hp: 生命值        """        self._name = name        self._hp = hp    @property    def name(self):        return self._name    @property    def hp(self):        return self._hp    @hp.setter    def hp(self, hp):        self._hp = hp if hp >= 0 else 0    @property    def alive(self):        return self._hp > 0    @abstractmethod    def attack(self, other):        """攻击        :param other: 被攻击的对象        """        passclass Ultraman(Fighter):    """奥特曼"""    __slots__ = ('_name', '_hp', '_mp')    def __init__(self, name, hp, mp):        """初始化方法        :param name: 名字        :param hp: 生命值        :param mp: 魔法值        """        super().__init__(name, hp)        self._mp = mp    def attack(self, other):        other.hp -= randint(15, 25)    def huge_attack(self, other):        """究极必杀技(打掉对方至少50点或四分之三的血)        :param other: 被攻击的对象        :return: 使用成功返回True否则返回False        """        if self._mp >= 50:            self._mp -= 50            injury = other.hp * 3 // 4            injury = injury if injury >= 50 else 50            other.hp -= injury            return True        else:            self.attack(other)            return False    def magic_attack(self, others):        """魔法攻击        :param others: 被攻击的群体        :return: 使用魔法成功返回True否则返回False        """        if self._mp >= 20:            self._mp -= 20            for temp in others:                if temp.alive:                    temp.hp -= randint(10, 15)            return True        else:            return False    def resume(self):        """恢复魔法值"""        incr_point = randint(1, 10)        self._mp += incr_point        return incr_point    def __str__(self):        return '~~~%s奥特曼~~~\n' % self._name + \            '生命值: %d\n' % self._hp + \            '魔法值: %d\n' % self._mpclass Monster(Fighter):    """小怪兽"""    __slots__ = ('_name', '_hp')    def attack(self, other):        other.hp -= randint(10, 20)    def __str__(self):        return '~~~%s小怪兽~~~\n' % self._name + \            '生命值: %d\n' % self._hpdef is_any_alive(monsters):    """判断有没有小怪兽是活着的"""    for monster in monsters:        if monster.alive > 0:            return True    return Falsedef select_alive_one(monsters):    """选中一只活着的小怪兽"""    monsters_len = len(monsters)    while True:        index = randrange(monsters_len)        monster = monsters[index]        if monster.alive > 0:            return monsterdef display_info(ultraman, monsters):    """显示奥特曼和小怪兽的信息"""    print(ultraman)    for monster in monsters:        print(monster, end='')def main():    u = Ultraman('骆昊', 1000, 120)    m1 = Monster('狄仁杰', 250)    m2 = Monster('白元芳', 500)    m3 = Monster('王大锤', 750)    ms = [m1, m2, m3]    fight_round = 1    while u.alive and is_any_alive(ms):        print('========第%02d回合========' % fight_round)        m = select_alive_one(ms)  # 选中一只小怪兽        skill = randint(1, 10)   # 通过随机数选择使用哪种技能        if skill <= 6:  # 60%的概率使用普通攻击            print('%s使用普通攻击打了%s.' % (u.name, m.name))            u.attack(m)            print('%s的魔法值恢复了%d点.' % (u.name, u.resume()))        elif skill <= 9:  # 30%的概率使用魔法攻击(可能因魔法值不足而失败)            if u.magic_attack(ms):                print('%s使用了魔法攻击.' % u.name)            else:                print('%s使用魔法失败.' % u.name)        else:  # 10%的概率使用究极必杀技(如果魔法值不足则使用普通攻击)            if u.huge_attack(m):                print('%s使用究极必杀技虐了%s.' % (u.name, m.name))            else:                print('%s使用普通攻击打了%s.' % (u.name, m.name))                print('%s的魔法值恢复了%d点.' % (u.name, u.resume()))        if m.alive > 0:  # 如果选中的小怪兽没有死就回击奥特曼            print('%s回击了%s.' % (m.name, u.name))            m.attack(u)        display_info(u, ms)  # 每个回合结束后显示奥特曼和小怪兽的信息        fight_round += 1    print('\n========战斗结束!========\n')    if u.alive > 0:        print('%s奥特曼胜利!' % u.name)    else:        print('小怪兽胜利!')if __name__ == '__main__':    main()</code></pre><h4 id="案例2：扑克游戏。"><a href="#案例2：扑克游戏。" class="headerlink" title="案例2：扑克游戏。"></a>案例2：扑克游戏。</h4><pre class=" language-Python"><code class="language-Python">import randomclass Card(object):    """一张牌"""    def __init__(self, suite, face):        self._suite = suite        self._face = face    @property    def face(self):        return self._face    @property    def suite(self):        return self._suite    def __str__(self):        if self._face == 1:            face_str = 'A'        elif self._face == 11:            face_str = 'J'        elif self._face == 12:            face_str = 'Q'        elif self._face == 13:            face_str = 'K'        else:            face_str = str(self._face)        return '%s%s' % (self._suite, face_str)    def __repr__(self):        return self.__str__()class Poker(object):    """一副牌"""    def __init__(self):        self._cards = [Card(suite, face)                        for suite in '♠♥♣♦'                       for face in range(1, 14)]        self._current = 0    @property    def cards(self):        return self._cards    def shuffle(self):        """洗牌(随机乱序)"""        self._current = 0        random.shuffle(self._cards)    @property    def next(self):        """发牌"""        card = self._cards[self._current]        self._current += 1        return card    @property    def has_next(self):        """还有没有牌"""        return self._current < len(self._cards)class Player(object):    """玩家"""    def __init__(self, name):        self._name = name        self._cards_on_hand = []    @property    def name(self):        return self._name    @property    def cards_on_hand(self):        return self._cards_on_hand    def get(self, card):        """摸牌"""        self._cards_on_hand.append(card)    def arrange(self, card_key):        """玩家整理手上的牌"""        self._cards_on_hand.sort(key=card_key)# 排序规则-先根据花色再根据点数排序def get_key(card):    return (card.suite, card.face)def main():    p = Poker()    p.shuffle()    players = [Player('东邪'), Player('西毒'), Player('南帝'), Player('北丐')]    for _ in range(13):        for player in players:            player.get(p.next)    for player in players:        print(player.name + ':', end=' ')        player.arrange(get_key)        print(player.cards_on_hand)if __name__ == '__main__':    main()</code></pre><blockquote><p><strong>说明：</strong> 大家可以自己尝试在上面代码的基础上写一个简单的扑克游戏，例如21点(Black Jack)，游戏的规则可以自己在网上找一找。</p></blockquote><h4 id="案例3：工资结算系统。"><a href="#案例3：工资结算系统。" class="headerlink" title="案例3：工资结算系统。"></a>案例3：工资结算系统。</h4><pre class=" language-Python"><code class="language-Python">"""某公司有三种类型的员工 分别是部门经理、程序员和销售员需要设计一个工资结算系统 根据提供的员工信息来计算月薪部门经理的月薪是每月固定15000元程序员的月薪按本月工作时间计算 每小时150元销售员的月薪是1200元的底薪加上销售额5%的提成"""from abc import ABCMeta, abstractmethodclass Employee(object, metaclass=ABCMeta):    """员工"""    def __init__(self, name):        """        初始化方法        :param name: 姓名        """        self._name = name    @property    def name(self):        return self._name    @abstractmethod    def get_salary(self):        """        获得月薪        :return: 月薪        """        passclass Manager(Employee):    """部门经理"""    def get_salary(self):        return 15000.0class Programmer(Employee):    """程序员"""    def __init__(self, name, working_hour=0):        super().__init__(name)        self._working_hour = working_hour    @property    def working_hour(self):        return self._working_hour    @working_hour.setter    def working_hour(self, working_hour):        self._working_hour = working_hour if working_hour > 0 else 0    def get_salary(self):        return 150.0 * self._working_hourclass Salesman(Employee):    """销售员"""    def __init__(self, name, sales=0):        super().__init__(name)        self._sales = sales    @property    def sales(self):        return self._sales    @sales.setter    def sales(self, sales):        self._sales = sales if sales > 0 else 0    def get_salary(self):        return 1200.0 + self._sales * 0.05def main():    emps = [        Manager('刘备'), Programmer('诸葛亮'),        Manager('曹操'), Salesman('荀彧'),        Salesman('吕布'), Programmer('张辽'),        Programmer('赵云')    ]    for emp in emps:        if isinstance(emp, Programmer):            emp.working_hour = int(input('请输入%s本月工作时间: ' % emp.name))        elif isinstance(emp, Salesman):            emp.sales = float(input('请输入%s本月销售额: ' % emp.name))        # 同样是接收get_salary这个消息但是不同的员工表现出了不同的行为(多态)        print('%s本月工资为: ￥%s元' %              (emp.name, emp.get_salary()))if __name__ == '__main__':    main()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python语言进阶</title>
      <link href="/2020/06/23/python/python-yu-yan-jin-jie/"/>
      <url>/2020/06/23/python/python-yu-yan-jin-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="Python语言进阶"><a href="#Python语言进阶" class="headerlink" title="Python语言进阶"></a>Python语言进阶</h2><h3 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h3><ul><li><p>生成式（推导式）的用法</p><pre class=" language-Python"><code class="language-Python">prices = {    'AAPL': 191.88,    'GOOG': 1186.96,    'IBM': 149.24,    'ORCL': 48.44,    'ACN': 166.89,    'FB': 208.09,    'SYMC': 21.29}# 用股票价格大于100元的股票构造一个新的字典prices2 = {key: value for key, value in prices.items() if value > 100}print(prices2)</code></pre><blockquote><p>说明：生成式（推导式）可以用来生成列表、集合和字典。</p></blockquote></li><li><p>嵌套的列表的坑</p><pre class=" language-Python"><code class="language-Python">names = ['关羽', '张飞', '赵云', '马超', '黄忠']courses = ['语文', '数学', '英语']# 录入五个学生三门课程的成绩# 错误 - 参考http://pythontutor.com/visualize.html#mode=edit# scores = [[None] * len(courses)] * len(names)scores = [[None] * len(courses) for _ in range(len(names))]for row, name in enumerate(names):    for col, course in enumerate(courses):        scores[row][col] = float(input(f'请输入{name}的{course}成绩: '))        print(scores)</code></pre><p><a href="http://pythontutor.com/" target="_blank" rel="noopener">Python Tutor</a> - VISUALIZE CODE AND GET LIVE HELP</p></li><li><p><code>heapq</code>模块（堆排序）</p><pre class=" language-Python"><code class="language-Python">"""从列表中找出最大的或最小的N个元素堆结构(大根堆/小根堆)"""import heapqlist1 = [34, 25, 12, 99, 87, 63, 58, 78, 88, 92]list2 = [    {'name': 'IBM', 'shares': 100, 'price': 91.1},    {'name': 'AAPL', 'shares': 50, 'price': 543.22},    {'name': 'FB', 'shares': 200, 'price': 21.09},    {'name': 'HPQ', 'shares': 35, 'price': 31.75},    {'name': 'YHOO', 'shares': 45, 'price': 16.35},    {'name': 'ACME', 'shares': 75, 'price': 115.65}]print(heapq.nlargest(3, list1))print(heapq.nsmallest(3, list1))print(heapq.nlargest(2, list2, key=lambda x: x['price']))print(heapq.nlargest(2, list2, key=lambda x: x['shares']))</code></pre></li><li><p><code>itertools</code>模块</p><pre class=" language-Python"><code class="language-Python">"""迭代工具模块"""import itertools# 产生ABCD的全排列itertools.permutations('ABCD')# 产生ABCDE的五选三组合itertools.combinations('ABCDE', 3)# 产生ABCD和123的笛卡尔积itertools.product('ABCD', '123')# 产生ABC的无限循环序列itertools.cycle(('A', 'B', 'C'))</code></pre></li><li><p><code>collections</code>模块</p><p>常用的工具类：</p><ul><li><code>namedtuple</code>：命令元组，它是一个类工厂，接受类型的名称和属性列表来创建一个类。</li><li><code>deque</code>：双端队列，是列表的替代实现。Python中的列表底层是基于数组来实现的，而deque底层是双向链表，因此当你需要在头尾添加和删除元素是，deque会表现出更好的性能，渐近时间复杂度为$O(1)$。</li><li><code>Counter</code>：<code>dict</code>的子类，键是元素，值是元素的计数，它的<code>most_common()</code>方法可以帮助我们获取出现频率最高的元素。<code>Counter</code>和<code>dict</code>的继承关系我认为是值得商榷的，按照CARP原则，<code>Counter</code>跟<code>dict</code>的关系应该设计为关联关系更为合理。</li><li><code>OrderedDict</code>：<code>dict</code>的子类，它记录了键值对插入的顺序，看起来既有字典的行为，也有链表的行为。</li><li><code>defaultdict</code>：类似于字典类型，但是可以通过默认的工厂函数来获得键对应的默认值，相比字典中的<code>setdefault()</code>方法，这种做法更加高效。</li></ul><pre class=" language-Python"><code class="language-Python">"""找出序列中出现次数最多的元素"""from collections import Counterwords = [    'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',    'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around',    'the', 'eyes', "don't", 'look', 'around', 'the', 'eyes',    'look', 'into', 'my', 'eyes', "you're", 'under']counter = Counter(words)print(counter.most_common(3))</code></pre></li></ul><h3 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><ul><li><p>算法：解决问题的方法和步骤</p></li><li><p>评价算法的好坏：渐近时间复杂度和渐近空间复杂度。</p></li><li><p>渐近时间复杂度的大O标记：</p><ul><li><img src="http://latex.codecogs.com/gif.latex?O(c)"> - 常量时间复杂度 - 布隆过滤器 / 哈希存储</li><li><img src="http://latex.codecogs.com/gif.latex?O(log_2n)"> - 对数时间复杂度 - 折半查找（二分查找）</li><li><img src="http://latex.codecogs.com/gif.latex?O(n)"> - 线性时间复杂度 - 顺序查找 / 计数排序</li><li><img src="http://latex.codecogs.com/gif.latex?O(n*log_2n)"> - 对数线性时间复杂度 - 高级排序算法（归并排序、快速排序）</li><li><img src="http://latex.codecogs.com/gif.latex?O(n^2)"> - 平方时间复杂度 - 简单排序算法（选择排序、插入排序、冒泡排序）</li><li><img src="http://latex.codecogs.com/gif.latex?O(n^3)"> - 立方时间复杂度 - Floyd算法 / 矩阵乘法运算</li><li><img src="http://latex.codecogs.com/gif.latex?O(2^n)"> - 几何级数时间复杂度 - 汉诺塔</li><li><img src="http://latex.codecogs.com/gif.latex?O(n!)"> - 阶乘时间复杂度 - 旅行经销商问题 - NPC</li></ul><p><img src="./res/algorithm_complexity_1.png" alt=""></p><p><img src="./res/algorithm_complexity_2.png" alt=""></p></li><li><p>排序算法（选择、冒泡和归并）和查找算法（顺序和折半）</p><pre class=" language-Python"><code class="language-Python">def select_sort(items, comp=lambda x, y: x < y):    """简单选择排序"""    items = items[:]    for i in range(len(items) - 1):        min_index = i        for j in range(i + 1, len(items)):            if comp(items[j], items[min_index]):                min_index = j        items[i], items[min_index] = items[min_index], items[i]    return items</code></pre><pre class=" language-Python"><code class="language-Python">def bubble_sort(items, comp=lambda x, y: x > y):    """冒泡排序"""    items = items[:]    for i in range(len(items) - 1):        swapped = False        for j in range(i, len(items) - 1 - i):            if comp(items[j], items[j + 1]):                items[j], items[j + 1] = items[j + 1], items[j]                swapped = True        if not swapped:            break    return items</code></pre><pre class=" language-Python"><code class="language-Python">def bubble_sort(items, comp=lambda x, y: x > y):    """搅拌排序(冒泡排序升级版)"""    items = items[:]    for i in range(len(items) - 1):        swapped = False        for j in range(i, len(items) - 1 - i):            if comp(items[j], items[j + 1]):                items[j], items[j + 1] = items[j + 1], items[j]                swapped = True        if swapped:            swapped = False            for j in range(len(items) - 2 - i, i, -1):                if comp(items[j - 1], items[j]):                    items[j], items[j - 1] = items[j - 1], items[j]                    swapped = True        if not swapped:            break    return items</code></pre><pre class=" language-Python"><code class="language-Python">def merge(items1, items2, comp=lambda x, y: x < y):    """合并(将两个有序的列表合并成一个有序的列表)"""    items = []    index1, index2 = 0, 0    while index1 < len(items1) and index2 < len(items2):        if comp(items1[index1], items2[index2]):            items.append(items1[index1])            index1 += 1        else:            items.append(items2[index2])            index2 += 1    items += items1[index1:]    items += items2[index2:]    return items</code></pre></li></ul><p>  def merge_sort(items, comp=lambda x, y: x &lt; y):<br>      return _merge_sort(list(items), comp)</p><p>  def _merge_sort(items, comp):<br>      “””归并排序”””<br>      if len(items) &lt; 2:<br>          return items<br>      mid = len(items) // 2<br>      left = _merge_sort(items[:mid], comp)<br>      right = _merge_sort(items[mid:], comp)<br>      return merge(left, right, comp)</p><pre><code>  ```Python  def seq_search(items, key):      """顺序查找"""      for index, item in enumerate(items):          if item == key:              return index      return -1</code></pre><pre class=" language-Python"><code class="language-Python">  def bin_search(items, key):      """折半查找"""      start, end = 0, len(items) - 1      while start <= end:          mid = (start + end) // 2          if key > items[mid]:              start = mid + 1          elif key < items[mid]:              end = mid - 1          else:              return mid      return -1</code></pre><ul><li><p>常用算法：</p><ul><li>穷举法 - 又称为暴力破解法，对所有的可能性进行验证，直到找到正确答案。</li><li>贪婪法 - 在对问题求解时，总是做出在当前看来</li><li>最好的选择，不追求最优解，快速找到满意解。</li><li>分治法 - 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题，直到可以直接求解的程度，最后将子问题的解进行合并得到原问题的解。</li><li>回溯法 - 回溯法又称为试探法，按选优条件向前搜索，当搜索到某一步发现原先选择并不优或达不到目标时，就退回一步重新选择。</li><li>动态规划 - 基本思想也是将待求解问题分解成若干个子问题，先求解并保存这些子问题的解，避免产生大量的重复运算。</li></ul><p>穷举法例子：百钱百鸡和五人分鱼。</p><pre class=" language-Python"><code class="language-Python"># 公鸡5元一只 母鸡3元一只 小鸡1元三只# 用100元买100只鸡 问公鸡/母鸡/小鸡各多少只for x in range(20):    for y in range(33):        z = 100 - x - y        if 5 * x + 3 * y + z // 3 == 100 and z % 3 == 0:            print(x, y, z)# A、B、C、D、E五人在某天夜里合伙捕鱼 最后疲惫不堪各自睡觉# 第二天A第一个醒来 他将鱼分为5份 扔掉多余的1条 拿走自己的一份# B第二个醒来 也将鱼分为5份 扔掉多余的1条 拿走自己的一份# 然后C、D、E依次醒来也按同样的方式分鱼 问他们至少捕了多少条鱼fish = 6while True:    total = fish    enough = True    for _ in range(5):        if (total - 1) % 5 == 0:            total = (total - 1) // 5 * 4        else:            enough = False            break    if enough:        print(fish)        break    fish += 5</code></pre><p>贪婪法例子：假设小偷有一个背包，最多能装20公斤赃物，他闯入一户人家，发现如下表所示的物品。很显然，他不能把所有物品都装进背包，所以必须确定拿走哪些物品，留下哪些物品。</p><table><thead><tr><th align="center">名称</th><th align="center">价格（美元）</th><th align="center">重量（kg）</th></tr></thead><tbody><tr><td align="center">电脑</td><td align="center">200</td><td align="center">20</td></tr><tr><td align="center">收音机</td><td align="center">20</td><td align="center">4</td></tr><tr><td align="center">钟</td><td align="center">175</td><td align="center">10</td></tr><tr><td align="center">花瓶</td><td align="center">50</td><td align="center">2</td></tr><tr><td align="center">书</td><td align="center">10</td><td align="center">1</td></tr><tr><td align="center">油画</td><td align="center">90</td><td align="center">9</td></tr></tbody></table><pre class=" language-Python"><code class="language-Python">"""贪婪法：在对问题求解时，总是做出在当前看来是最好的选择，不追求最优解，快速找到满意解。输入：20 6电脑 200 20收音机 20 4钟 175 10花瓶 50 2书 10 1油画 90 9"""class Thing(object):    """物品"""    def __init__(self, name, price, weight):        self.name = name        self.price = price        self.weight = weight    @property    def value(self):        """价格重量比"""        return self.price / self.weight</code></pre></li></ul><p>  def input_thing():<br>      “””输入物品信息”””<br>      name_str, price_str, weight_str = input().split()<br>      return name_str, int(price_str), int(weight_str)</p><p>  def main():<br>      “””主函数”””<br>      max_weight, num_of_things = map(int, input().split())<br>      all_things = []<br>      for _ in range(num_of_things):<br>          all_things.append(Thing(*input_thing()))<br>      all_things.sort(key=lambda x: x.value, reverse=True)<br>      total_weight = 0<br>      total_price = 0<br>      for thing in all_things:<br>          if total_weight + thing.weight &lt;= max_weight:<br>              print(f’小偷拿走了{thing.name}’)<br>              total_weight += thing.weight<br>              total_price += thing.price<br>      print(f’总价值: {total_price}美元’)</p><p>  if <strong>name</strong> == ‘<strong>main</strong>‘:<br>      main()</p><pre><code>  分治法例子：[快速排序](https://zh.wikipedia.org/zh/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)。  ```Python  """  快速排序 - 选择枢轴对元素进行划分，左边都比枢轴小右边都比枢轴大  """  def quick_sort(items, comp=lambda x, y: x &lt;= y):      items = list(items)[:]      _quick_sort(items, 0, len(items) - 1, comp)      return items  def _quick_sort(items, start, end, comp):      if start &lt; end:          pos = _partition(items, start, end, comp)          _quick_sort(items, start, pos - 1, comp)          _quick_sort(items, pos + 1, end, comp)  def _partition(items, start, end, comp):      pivot = items[end]      i = start - 1      for j in range(start, end):          if comp(items[j], pivot):              i += 1              items[i], items[j] = items[j], items[i]      items[i + 1], items[end] = items[end], items[i + 1]      return i + 1</code></pre><p>  回溯法例子：<a href="https://zh.wikipedia.org/zh/%E9%AA%91%E5%A3%AB%E5%B7%A1%E9%80%BB" target="_blank" rel="noopener">骑士巡逻</a>。</p><pre class=" language-Python"><code class="language-Python">  """  递归回溯法：叫称为试探法，按选优条件向前搜索，当搜索到某一步，发现原先选择并不优或达不到目标时，就退回一步重新选择，比较经典的问题包括骑士巡逻、八皇后和迷宫寻路等。  """  import sys  import time  SIZE = 5  total = 0  def print_board(board):      for row in board:          for col in row:              print(str(col).center(4), end='')          print()  def patrol(board, row, col, step=1):      if row >= 0 and row < SIZE and \          col >= 0 and col < SIZE and \          board[row][col] == 0:          board[row][col] = step          if step == SIZE * SIZE:              global total              total += 1              print(f'第{total}种走法: ')              print_board(board)          patrol(board, row - 2, col - 1, step + 1)          patrol(board, row - 1, col - 2, step + 1)          patrol(board, row + 1, col - 2, step + 1)          patrol(board, row + 2, col - 1, step + 1)          patrol(board, row + 2, col + 1, step + 1)          patrol(board, row + 1, col + 2, step + 1)          patrol(board, row - 1, col + 2, step + 1)          patrol(board, row - 2, col + 1, step + 1)          board[row][col] = 0  def main():      board = [[0] * SIZE for _ in range(SIZE)]      patrol(board, SIZE - 1, SIZE - 1)  if __name__ == '__main__':      main()</code></pre><p>  动态规划例子：子列表元素之和的最大值。</p><blockquote><p>说明：子列表指的是列表中索引（下标）连续的元素构成的列表；列表中的元素是int类型，可能包含正整数、0、负整数；程序输入列表中的元素，输出子列表元素求和的最大值，例如：</p><p>输入：1 -2 3 5 -3 2</p><p>输出：8</p><p>输入：0 -2 3 5 -1 2</p><p>输出：9</p><p>输入：-9 -2 -3 -5 -3</p><p>输出：-2</p></blockquote><pre class=" language-Python"><code class="language-Python">  def main():      items = list(map(int, input().split()))      overall = partial = items[0]      for i in range(1, len(items)):          partial = max(items[i], partial + items[i])          overall = max(partial, overall)      print(overall)  if __name__ == '__main__':      main()</code></pre><blockquote><p><strong>说明</strong>：这个题目最容易想到的解法是使用二重循环，但是代码的时间性能将会变得非常的糟糕。使用动态规划的思想，仅仅是多用了两个变量，就将原来$O(N^2)$复杂度的问题变成了$O(N)$。</p></blockquote><h3 id="函数的使用方式"><a href="#函数的使用方式" class="headerlink" title="函数的使用方式"></a>函数的使用方式</h3><ul><li><p>将函数视为“一等公民”</p><ul><li>函数可以赋值给变量</li><li>函数可以作为函数的参数</li><li>函数可以作为函数的返回值</li></ul></li><li><p>高阶函数的用法（<code>filter</code>、<code>map</code>以及它们的替代品）</p><pre class=" language-Python"><code class="language-Python">items1 = list(map(lambda x: x ** 2, filter(lambda x: x % 2, range(1, 10))))items2 = [x ** 2 for x in range(1, 10) if x % 2]</code></pre></li><li><p>位置参数、可变参数、关键字参数、命名关键字参数</p></li><li><p>参数的元信息（代码可读性问题）</p></li><li><p>匿名函数和内联函数的用法（<code>lambda</code>函数）</p></li><li><p>闭包和作用域问题</p><ul><li><p>Python搜索变量的LEGB顺序（Local &gt;&gt;&gt; Embedded &gt;&gt;&gt; Global &gt;&gt;&gt; Built-in）</p></li><li><p><code>global</code>和<code>nonlocal</code>关键字的作用</p><p><code>global</code>：声明或定义全局变量（要么直接使用现有的全局作用域的变量，要么定义一个变量放到全局作用域）。</p><p><code>nonlocal</code>：声明使用嵌套作用域的变量（嵌套作用域必须存在该变量，否则报错）。</p></li></ul></li><li><p>装饰器函数（使用装饰器和取消装饰器）</p><p>例子：输出函数执行时间的装饰器。</p><pre class=" language-Python"><code class="language-Python">def record_time(func):    """自定义装饰函数的装饰器"""    @wraps(func)    def wrapper(*args, **kwargs):        start = time()        result = func(*args, **kwargs)        print(f'{func.__name__}: {time() - start}秒')        return result    return wrapper</code></pre><p>如果装饰器不希望跟<code>print</code>函数耦合，可以编写可以参数化的装饰器。</p><pre class=" language-Python"><code class="language-Python">from functools import wrapsfrom time import time</code></pre></li></ul><p>  def record(output):<br>      “””可以参数化的装饰器”””</p><pre><code>  def decorate(func):      @wraps(func)      def wrapper(*args, **kwargs):          start = time()          result = func(*args, **kwargs)          output(func.__name__, time() - start)          return result      return wrapper  return decorate</code></pre><pre><code>  ```Python  from functools import wraps  from time import time  class Record():      """通过定义类的方式定义装饰器"""      def __init__(self, output):          self.output = output      def __call__(self, func):          @wraps(func)          def wrapper(*args, **kwargs):              start = time()              result = func(*args, **kwargs)              self.output(func.__name__, time() - start)              return result          return wrapper</code></pre><blockquote><p><strong>说明</strong>：由于对带装饰功能的函数添加了@wraps装饰器，可以通过<code>func.__wrapped__</code>方式获得被装饰之前的函数或类来取消装饰器的作用。</p></blockquote><p>  例子：用装饰器来实现单例模式。</p><pre class=" language-Python"><code class="language-Python">  from functools import wraps  def singleton(cls):      """装饰类的装饰器"""      instances = {}      @wraps(cls)      def wrapper(*args, **kwargs):          if cls not in instances:              instances[cls] = cls(*args, **kwargs)          return instances[cls]      return wrapper  @singleton  class President:      """总统(单例类)"""      pass</code></pre><blockquote><p><strong>提示</strong>：上面的代码中用到了闭包（closure），不知道你是否已经意识到了。还没有一个小问题就是，上面的代码并没有实现线程安全的单例，如果要实现线程安全的单例应该怎么做呢？</p></blockquote><p>  线程安全的单例装饰器。</p><pre class=" language-Python"><code class="language-Python">  from functools import wraps  from threading import RLock  def singleton(cls):      """线程安全的单例装饰器"""      instances = {}      locker = RLock()      @wraps(cls)      def wrapper(*args, **kwargs):          if cls not in instances:              with locker:                  if cls not in instances:                      instances[cls] = cls(*args, **kwargs)          return instances[cls]      return wrapper</code></pre><blockquote><p><strong>提示</strong>：上面的代码用到了<code>with</code>上下文语法来进行锁操作，因为锁对象本身就是上下文管理器对象（支持<code>__enter__</code>和<code>__exit__</code>魔术方法）。在<code>wrapper</code>函数中，我们先做了一次不带锁的检查，然后再做带锁的检查，这样做比直接加锁检查性能要更好，如果对象已经创建就没有必须再去加锁而是直接返回该对象就可以了。</p></blockquote><h3 id="面向对象相关知识"><a href="#面向对象相关知识" class="headerlink" title="面向对象相关知识"></a>面向对象相关知识</h3><ul><li><p>三大支柱：封装、继承、多态</p><p>例子：工资结算系统。</p><pre class=" language-Python"><code class="language-Python">"""月薪结算系统 - 部门经理每月15000 程序员每小时200 销售员1800底薪加销售额5%提成"""from abc import ABCMeta, abstractmethod</code></pre></li></ul><p>  class Employee(metaclass=ABCMeta):<br>      “””员工(抽象类)”””</p><pre><code>  def __init__(self, name):      self.name = name  @abstractmethod  def get_salary(self):      """结算月薪(抽象方法)"""      pass</code></pre><p>  class Manager(Employee):<br>      “””部门经理”””</p><pre><code>  def get_salary(self):      return 15000.0</code></pre><p>  class Programmer(Employee):<br>      “””程序员”””</p><pre><code>  def __init__(self, name, working_hour=0):      self.working_hour = working_hour      super().__init__(name)  def get_salary(self):      return 200.0 * self.working_hour</code></pre><p>  class Salesman(Employee):<br>      “””销售员”””</p><pre><code>  def __init__(self, name, sales=0.0):      self.sales = sales      super().__init__(name)  def get_salary(self):      return 1800.0 + self.sales * 0.05</code></pre><p>  class EmployeeFactory:<br>      “””创建员工的工厂（工厂模式 - 通过工厂实现对象使用者和对象之间的解耦合）”””</p><pre><code>  @staticmethod  def create(emp_type, *args, **kwargs):      """创建员工"""      all_emp_types = {'M': Manager, 'P': Programmer, 'S': Salesman}      cls = all_emp_types[emp_type.upper()]      return cls(*args, **kwargs) if cls else None</code></pre><p>  def main():<br>      “””主函数”””<br>      emps = [<br>          EmployeeFactory.create(‘M’, ‘曹操’),<br>          EmployeeFactory.create(‘P’, ‘荀彧’, 120),<br>          EmployeeFactory.create(‘P’, ‘郭嘉’, 85),<br>          EmployeeFactory.create(‘S’, ‘典韦’, 123000),<br>      ]<br>      for emp in emps:<br>          print(f’{emp.name}: {emp.get_salary():.2f}元’)</p><p>  if <strong>name</strong> == ‘<strong>main</strong>‘:<br>      main()</p><pre><code>- 类与类之间的关系  - is-a关系：继承  - has-a关系：关联 / 聚合 / 合成  - use-a关系：依赖  例子：扑克游戏。  ```Python  """  经验：符号常量总是优于字面常量，枚举类型是定义符号常量的最佳选择  """  from enum import Enum, unique  import random  @unique  class Suite(Enum):      """花色"""      SPADE, HEART, CLUB, DIAMOND = range(4)      def __lt__(self, other):          return self.value &lt; other.value  class Card():      """牌"""      def __init__(self, suite, face):          """初始化方法"""          self.suite = suite          self.face = face      def show(self):          """显示牌面"""          suites = ['♠︎', '♥︎', '♣︎', '♦︎']          faces = ['', 'A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']          return f'{suites[self.suite.value]}{faces[self.face]}'      def __repr__(self):          return self.show()  class Poker():      """扑克"""      def __init__(self):          self.index = 0          self.cards = [Card(suite, face)                        for suite in Suite                        for face in range(1, 14)]      def shuffle(self):          """洗牌（随机乱序）"""          random.shuffle(self.cards)          self.index = 0      def deal(self):          """发牌"""          card = self.cards[self.index]          self.index += 1          return card      @property      def has_more(self):          return self.index &lt; len(self.cards)  class Player():      """玩家"""      def __init__(self, name):          self.name = name          self.cards = []      def get_one(self, card):          """摸一张牌"""          self.cards.append(card)      def sort(self, comp=lambda card: (card.suite, card.face)):          """整理手上的牌"""          self.cards.sort(key=comp)  def main():      """主函数"""      poker = Poker()      poker.shuffle()      players = [Player('东邪'), Player('西毒'), Player('南帝'), Player('北丐')]      while poker.has_more:          for player in players:                  player.get_one(poker.deal())      for player in players:          player.sort()          print(player.name, end=': ')          print(player.cards)  if __name__ == '__main__':      main()</code></pre><blockquote><p><strong>说明</strong>：上面的代码中使用了Emoji字符来表示扑克牌的四种花色，在某些不支持Emoji字符的系统上可能无法显示。</p></blockquote><ul><li><p>对象的复制（深复制/深拷贝/深度克隆和浅复制/浅拷贝/影子克隆）</p></li><li><p>垃圾回收、循环引用和弱引用</p><p>Python使用了自动化内存管理，这种管理机制以<strong>引用计数</strong>为基础，同时也引入了<strong>标记-清除</strong>和<strong>分代收集</strong>两种机制为辅的策略。</p><pre class=" language-C"><code class="language-C">typedef struct_object {    /* 引用计数 */    int ob_refcnt;    /* 对象指针 */    struct_typeobject *ob_type;} PyObject;</code></pre><pre class=" language-C"><code class="language-C">/* 增加引用计数的宏定义 */#define Py_INCREF(op)   ((op)->ob_refcnt++)/* 减少引用计数的宏定义 */#define Py_DECREF(op) \ //减少计数    if (--(op)->ob_refcnt != 0) \        ; \    else \        __Py_Dealloc((PyObject *)(op))</code></pre><p>导致引用计数+1的情况：</p><ul><li>对象被创建，例如<code>a = 23</code></li><li>对象被引用，例如<code>b = a</code></li><li>对象被作为参数，传入到一个函数中，例如<code>f(a)</code></li><li>对象作为一个元素，存储在容器中，例如<code>list1 = [a, a]</code></li></ul><p>导致引用计数-1的情况：</p><ul><li>对象的别名被显式销毁，例如<code>del a</code></li><li>对象的别名被赋予新的对象，例如<code>a = 24</code></li><li>一个对象离开它的作用域，例如f函数执行完毕时，f函数中的局部变量（全局变量不会）</li><li>对象所在的容器被销毁，或从容器中删除对象</li></ul><p>引用计数可能会导致循环引用问题，而循环引用会导致内存泄露，如下面的代码所示。为了解决这个问题，Python中引入了“标记-清除”和“分代收集”。在创建一个对象的时候，对象被放在第一代中，如果在第一代的垃圾检查中对象存活了下来，该对象就会被放到第二代中，同理在第二代的垃圾检查中对象存活下来，该对象就会被放到第三代中。</p><pre class=" language-Python"><code class="language-Python"># 循环引用会导致内存泄露 - Python除了引用技术还引入了标记清理和分代回收# 在Python 3.6以前如果重写__del__魔术方法会导致循环引用处理失效# 如果不想造成循环引用可以使用弱引用list1 = []list2 = [] list1.append(list2)list2.append(list1)</code></pre><p>以下情况会导致垃圾回收：</p><ul><li>调用<code>gc.collect()</code></li><li><code>gc</code>模块的计数器达到阀值</li><li>程序退出</li></ul><p>如果循环引用中两个对象都定义了<code>__del__</code>方法，<code>gc</code>模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的<code>__del__</code>方法，这个问题在Python 3.6中得到了解决。</p><p>也可以通过<code>weakref</code>模块构造弱引用的方式来解决循环引用的问题。</p></li><li><p>魔法属性和方法（请参考《Python魔法方法指南》）</p><p>有几个小问题请大家思考：</p><ul><li>自定义的对象能不能使用运算符做运算？</li><li>自定义的对象能不能放到<code>set</code>中？能去重吗？</li><li>自定义的对象能不能作为<code>dict</code>的键？</li><li>自定义的对象能不能使用上下文语法？</li></ul></li><li><p>混入（Mixin）</p><p>例子：自定义字典限制只有在指定的key不存在时才能在字典中设置键值对。</p><pre class=" language-Python"><code class="language-Python">class SetOnceMappingMixin:    """自定义混入类"""    __slots__ = ()    def __setitem__(self, key, value):        if key in self:            raise KeyError(str(key) + ' already set')        return super().__setitem__(key, value)</code></pre></li></ul><p>  class SetOnceDict(SetOnceMappingMixin, dict):<br>      “””自定义字典”””<br>      pass</p><p>  my_dict= SetOnceDict()<br>  try:<br>      my_dict[‘username’] = ‘jackfrued’<br>      my_dict[‘username’] = ‘hellokitty’<br>  except KeyError:<br>      pass<br>  print(my_dict)</p><pre><code>- 元编程和元类  对象是通过类创建的，类是通过元类创建的，元类提供了创建类的元信息。所有的类都直接或间接的继承自`object`，所有的元类都直接或间接的继承自`type`。  例子：用元类实现单例模式。  ```Python  import threading  class SingletonMeta(type):      """自定义元类"""      def __init__(cls, *args, **kwargs):          cls.__instance = None          cls.__lock = threading.RLock()          super().__init__(*args, **kwargs)      def __call__(cls, *args, **kwargs):          if cls.__instance is None:              with cls.__lock:                  if cls.__instance is None:                      cls.__instance = super().__call__(*args, **kwargs)          return cls.__instance  class President(metaclass=SingletonMeta):      """总统(单例类)"""      pass</code></pre><ul><li><p>面向对象设计原则</p><ul><li>单一职责原则 （<strong>S</strong>RP）- 一个类只做该做的事情（类的设计要高内聚）</li><li>开闭原则 （<strong>O</strong>CP）- 软件实体应该对扩展开发对修改关闭</li><li>依赖倒转原则（DIP）- 面向抽象编程（在弱类型语言中已经被弱化）</li><li>里氏替换原则（<strong>L</strong>SP） - 任何时候可以用子类对象替换掉父类对象</li><li>接口隔离原则（<strong>I</strong>SP）- 接口要小而专不要大而全（Python中没有接口的概念）</li><li>合成聚合复用原则（CARP） - 优先使用强关联关系而不是继承关系复用代码</li><li>最少知识原则（迪米特法则，Lo<strong>D</strong>）- 不要给没有必然联系的对象发消息</li></ul><blockquote><p><strong>说明</strong>：上面加粗的字母放在一起称为面向对象的<strong>SOLID</strong>原则。</p></blockquote></li><li><p>GoF设计模式</p><ul><li>创建型模式：单例、工厂、建造者、原型</li><li>结构型模式：适配器、门面（外观）、代理</li><li>行为型模式：迭代器、观察者、状态、策略</li></ul><p>例子：可插拔的哈希算法（策略模式）。</p><pre class=" language-Python"><code class="language-Python">class StreamHasher():    """哈希摘要生成器"""    def __init__(self, alg='md5', size=4096):        self.size = size        alg = alg.lower()        self.hasher = getattr(__import__('hashlib'), alg.lower())()    def __call__(self, stream):        return self.to_digest(stream)    def to_digest(self, stream):        """生成十六进制形式的摘要"""        for buf in iter(lambda: stream.read(self.size), b''):            self.hasher.update(buf)        return self.hasher.hexdigest()def main():    """主函数"""    hasher1 = StreamHasher()    with open('Python-3.7.6.tgz', 'rb') as stream:        print(hasher1.to_digest(stream))    hasher2 = StreamHasher('sha1')    with open('Python-3.7.6.tgz', 'rb') as stream:        print(hasher2(stream))</code></pre></li></ul><p>  if <strong>name</strong> == ‘<strong>main</strong>‘:<br>      main()</p><pre><code>### 迭代器和生成器- 迭代器是实现了迭代器协议的对象。  - Python中没有像`protocol`或`interface`这样的定义协议的关键字。  - Python中用魔术方法表示协议。  - `__iter__`和`__next__`魔术方法就是迭代器协议。  ```Python  class Fib(object):      """迭代器"""      def __init__(self, num):          self.num = num          self.a, self.b = 0, 1          self.idx = 0      def __iter__(self):          return self      def __next__(self):          if self.idx &lt; self.num:              self.a, self.b = self.b, self.a + self.b              self.idx += 1              return self.a          raise StopIteration()</code></pre><ul><li><p>生成器是语法简化版的迭代器。</p><pre class=" language-Python"><code class="language-Python">def fib(num):    """生成器"""    a, b = 0, 1    for _ in range(num):        a, b = b, a + b        yield a</code></pre></li><li><p>生成器进化为协程。</p><p>生成器对象可以使用<code>send()</code>方法发送数据，发送的数据会成为生成器函数中通过<code>yield</code>表达式获得的值。这样，生成器就可以作为协程使用，协程简单的说就是可以相互协作的子程序。</p><pre class=" language-Python"><code class="language-Python">def calc_avg():    """流式计算平均值"""    total, counter = 0, 0    avg_value = None    while True:        value = yield avg_value        total, counter = total + value, counter + 1        avg_value = total / counter</code></pre></li></ul><p>  gen = calc_avg()<br>  next(gen)<br>  print(gen.send(10))<br>  print(gen.send(20))<br>  print(gen.send(30))</p><pre><code>### 并发编程Python中实现并发编程的三种方案：多线程、多进程和异步I/O。并发编程的好处在于可以提升程序的执行效率以及改善用户体验；坏处在于并发的程序不容易开发和调试，同时对其他程序来说它并不友好。- 多线程：Python中提供了`Thread`类并辅以`Lock`、`Condition`、`Event`、`Semaphore`和`Barrier`。Python中有GIL来防止多个线程同时执行本地字节码，这个锁对于CPython是必须的，因为CPython的内存管理并不是线程安全的，因为GIL的存在多线程并不能发挥CPU的多核特性。  ```Python  """  面试题：进程和线程的区别和联系？  进程 - 操作系统分配内存的基本单位 - 一个进程可以包含一个或多个线程  线程 - 操作系统分配CPU的基本单位  并发编程（concurrent programming）  1. 提升执行性能 - 让程序中没有因果关系的部分可以并发的执行  2. 改善用户体验 - 让耗时间的操作不会造成程序的假死  """  import glob  import os  import threading  from PIL import Image  PREFIX = 'thumbnails'  def generate_thumbnail(infile, size, format='PNG'):      """生成指定图片文件的缩略图"""      file, ext = os.path.splitext(infile)      file = file[file.rfind('/') + 1:]      outfile = f'{PREFIX}/{file}_{size[0]}_{size[1]}.{ext}'      img = Image.open(infile)      img.thumbnail(size, Image.ANTIALIAS)      img.save(outfile, format)  def main():      """主函数"""      if not os.path.exists(PREFIX):          os.mkdir(PREFIX)      for infile in glob.glob('images/*.png'):          for size in (32, 64, 128):              # 创建并启动线程              threading.Thread(                  target=generate_thumbnail,                   args=(infile, (size, size))              ).start()  if __name__ == '__main__':      main()</code></pre><p>  多个线程竞争资源的情况。</p><pre class=" language-Python"><code class="language-Python">  """  多线程程序如果没有竞争资源处理起来通常也比较简单  当多个线程竞争临界资源的时候如果缺乏必要的保护措施就会导致数据错乱  说明：临界资源就是被多个线程竞争的资源  """  import time  import threading  from concurrent.futures import ThreadPoolExecutor  class Account(object):      """银行账户"""      def __init__(self):          self.balance = 0.0          self.lock = threading.Lock()      def deposit(self, money):          # 通过锁保护临界资源          with self.lock:              new_balance = self.balance + money              time.sleep(0.001)              self.balance = new_balance  class AddMoneyThread(threading.Thread):      """自定义线程类"""      def __init__(self, account, money):          self.account = account          self.money = money          # 自定义线程的初始化方法中必须调用父类的初始化方法          super().__init__()      def run(self):          # 线程启动之后要执行的操作          self.account.deposit(self.money)  def main():      """主函数"""      account = Account()      # 创建线程池      pool = ThreadPoolExecutor(max_workers=10)      futures = []      for _ in range(100):          # 创建线程的第1种方式          # threading.Thread(          #     target=account.deposit, args=(1, )          # ).start()          # 创建线程的第2种方式          # AddMoneyThread(account, 1).start()          # 创建线程的第3种方式          # 调用线程池中的线程来执行特定的任务          future = pool.submit(account.deposit, 1)          futures.append(future)      # 关闭线程池      pool.shutdown()      for future in futures:          future.result()      print(account.balance)  if __name__ == '__main__':      main()</code></pre><p>  修改上面的程序，启动5个线程向账户中存钱，5个线程从账户中取钱，取钱时如果余额不足就暂停线程进行等待。为了达到上述目标，需要对存钱和取钱的线程进行调度，在余额不足时取钱的线程暂停并释放锁，而存钱的线程将钱存入后要通知取钱的线程，使其从暂停状态被唤醒。可以使用<code>threading</code>模块的<code>Condition</code>来实现线程调度，该对象也是基于锁来创建的，代码如下所示：</p><pre class=" language-Python"><code class="language-Python">  """  多个线程竞争一个资源 - 保护临界资源 - 锁（Lock/RLock）  多个线程竞争多个资源（线程数>资源数） - 信号量（Semaphore）  多个线程的调度 - 暂停线程执行/唤醒等待中的线程 - Condition  """  from concurrent.futures import ThreadPoolExecutor  from random import randint  from time import sleep  import threading  class Account():      """银行账户"""      def __init__(self, balance=0):          self.balance = balance          lock = threading.Lock()          self.condition = threading.Condition(lock)      def withdraw(self, money):          """取钱"""          with self.condition:              while money > self.balance:                  self.condition.wait()              new_balance = self.balance - money              sleep(0.001)              self.balance = new_balance      def deposit(self, money):          """存钱"""          with self.condition:              new_balance = self.balance + money              sleep(0.001)              self.balance = new_balance              self.condition.notify_all()  def add_money(account):      while True:          money = randint(5, 10)          account.deposit(money)          print(threading.current_thread().name,                 ':', money, '====>', account.balance)          sleep(0.5)  def sub_money(account):      while True:          money = randint(10, 30)          account.withdraw(money)          print(threading.current_thread().name,                 ':', money, '<====', account.balance)          sleep(1)  def main():      account = Account()      with ThreadPoolExecutor(max_workers=10) as pool:          for _ in range(5):              pool.submit(add_money, account)              pool.submit(sub_money, account)  if __name__ == '__main__':      main()</code></pre><ul><li><p>多进程：多进程可以有效的解决GIL的问题，实现多进程主要的类是<code>Process</code>，其他辅助的类跟<code>threading</code>模块中的类似，进程间共享数据可以使用管道、套接字等，在<code>multiprocessing</code>模块中有一个<code>Queue</code>类，它基于管道和锁机制提供了多个进程共享的队列。下面是官方文档上关于多进程和进程池的一个示例。</p><pre class=" language-Python"><code class="language-Python">"""多进程和进程池的使用多线程因为GIL的存在不能够发挥CPU的多核特性对于计算密集型任务应该考虑使用多进程time python3 example22.pyreal    0m11.512suser    0m39.319ssys     0m0.169s使用多进程后实际执行时间为11.512秒，而用户时间39.319秒约为实际执行时间的4倍这就证明我们的程序通过多进程使用了CPU的多核特性，而且这台计算机配置了4核的CPU"""import concurrent.futuresimport mathPRIMES = [    1116281,    1297337,    104395303,    472882027,    533000389,    817504243,    982451653,    112272535095293,    112582705942171,    112272535095293,    115280095190773,    115797848077099,    1099726899285419] * 5</code></pre></li></ul><p>  def is_prime(n):<br>      “””判断素数”””<br>      if n % 2 == 0:<br>          return False</p><pre><code>  sqrt_n = int(math.floor(math.sqrt(n)))  for i in range(3, sqrt_n + 1, 2):      if n % i == 0:          return False  return True</code></pre><p>  def main():<br>      “””主函数”””<br>      with concurrent.futures.ProcessPoolExecutor() as executor:<br>          for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):<br>              print(‘%d is prime: %s’ % (number, prime))</p><p>  if <strong>name</strong> == ‘<strong>main</strong>‘:<br>      main()</p><pre><code>  &gt; **重点**：**多线程和多进程的比较**。  &gt;  &gt; 以下情况需要使用多线程：  &gt;  &gt; 1. 程序需要维护许多共享的状态（尤其是可变状态），Python中的列表、字典、集合都是线程安全的，所以使用线程而不是进程维护共享状态的代价相对较小。  &gt; 2. 程序会花费大量时间在I/O操作上，没有太多并行计算的需求且不需占用太多的内存。  &gt;  &gt; 以下情况需要使用多进程：  &gt;  &gt; 1. 程序执行计算密集型任务（如：字节码操作、数据处理、科学计算）。  &gt; 2. 程序的输入可以并行的分成块，并且可以将运算结果合并。  &gt; 3. 程序在内存使用方面没有任何限制且不强依赖于I/O操作（如：读写文件、套接字等）。- 异步处理：从调度程序的任务队列中挑选任务，该调度程序以交叉的形式执行这些任务，我们并不能保证任务将以某种顺序去执行，因为执行顺序取决于队列中的一项任务是否愿意将CPU处理时间让位给另一项任务。异步任务通常通过多任务协作处理的方式来实现，由于执行时间和顺序的不确定，因此需要通过回调式编程或者`future`对象来获取任务执行的结果。Python 3通过`asyncio`模块和`await`和`async`关键字（在Python 3.7中正式被列为关键字）来支持异步处理。  ```Python  """  异步I/O - async / await  """  import asyncio  def num_generator(m, n):      """指定范围的数字生成器"""      yield from range(m, n + 1)  async def prime_filter(m, n):      """素数过滤器"""      primes = []      for i in num_generator(m, n):          flag = True          for j in range(2, int(i ** 0.5 + 1)):              if i % j == 0:                  flag = False                  break          if flag:              print('Prime =&gt;', i)              primes.append(i)          await asyncio.sleep(0.001)      return tuple(primes)  async def square_mapper(m, n):      """平方映射器"""      squares = []      for i in num_generator(m, n):          print('Square =&gt;', i * i)          squares.append(i * i)          await asyncio.sleep(0.001)      return squares  def main():      """主函数"""      loop = asyncio.get_event_loop()      future = asyncio.gather(prime_filter(2, 100), square_mapper(1, 100))      future.add_done_callback(lambda x: print(x.result()))      loop.run_until_complete(future)      loop.close()  if __name__ == '__main__':      main()</code></pre><blockquote><p><strong>说明</strong>：上面的代码使用<code>get_event_loop</code>函数获得系统默认的事件循环，通过<code>gather</code>函数可以获得一个<code>future</code>对象，<code>future</code>对象的<code>add_done_callback</code>可以添加执行完成时的回调函数，<code>loop</code>对象的<code>run_until_complete</code>方法可以等待通过<code>future</code>对象获得协程执行结果。</p></blockquote><p>  Python中有一个名为<code>aiohttp</code>的三方库，它提供了异步的HTTP客户端和服务器，这个三方库可以跟<code>asyncio</code>模块一起工作，并提供了对<code>Future</code>对象的支持。Python 3.6中引入了<code>async</code>和<code>await</code>来定义异步执行的函数以及创建异步上下文，在Python 3.7中它们正式成为了关键字。下面的代码异步的从5个URL中获取页面并通过正则表达式的命名捕获组提取了网站的标题。</p><pre class=" language-Python"><code class="language-Python">  import asyncio  import re  import aiohttp  PATTERN = re.compile(r'\<title\>(?P<title>.*)\<\/title\>')  async def fetch_page(session, url):      async with session.get(url, ssl=False) as resp:          return await resp.text()  async def show_title(url):      async with aiohttp.ClientSession() as session:          html = await fetch_page(session, url)          print(PATTERN.search(html).group('title'))  def main():      urls = ('https://www.python.org/',              'https://git-scm.com/',              'https://www.jd.com/',              'https://www.taobao.com/',              'https://www.douban.com/')      loop = asyncio.get_event_loop()      cos = [show_title(url) for url in urls]      loop.run_until_complete(asyncio.wait(cos))      loop.close()  if __name__ == '__main__':      main()</code></pre><blockquote><p><strong>重点</strong>：<strong>异步I/O与多进程的比较</strong>。</p><p>当程序不需要真正的并发性或并行性，而是更多的依赖于异步处理和回调时，<code>asyncio</code>就是一种很好的选择。如果程序中有大量的等待与休眠时，也应该考虑<code>asyncio</code>，它很适合编写没有实时数据处理需求的Web应用服务器。</p></blockquote><p>  Python还有很多用于处理并行任务的三方库，例如：<code>joblib</code>、<code>PyMP</code>等。实际开发中，要提升系统的可扩展性和并发性通常有垂直扩展（增加单个节点的处理能力）和水平扩展（将单个节点变成多个节点）两种做法。可以通过消息队列来实现应用程序的解耦合，消息队列相当于是多线程同步队列的扩展版本，不同机器上的应用程序相当于就是线程，而共享的分布式消息队列就是原来程序中的Queue。消息队列（面向消息的中间件）的最流行和最标准化的实现是AMQP（高级消息队列协议），AMQP源于金融行业，提供了排队、路由、可靠传输、安全等功能，最著名的实现包括：Apache的ActiveMQ、RabbitMQ等。</p><p>  要实现任务的异步化，可以使用名为<code>Celery</code>的三方库。<code>Celery</code>是Python编写的分布式任务队列，它使用分布式消息进行工作，可以基于RabbitMQ或Redis来作为后端的消息代理。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个小例子助你彻底理解协程</title>
      <link href="/2020/06/18/python/yi-ge-xiao-li-zi-zhu-ni-che-di-li-jie-xie-cheng/"/>
      <url>/2020/06/18/python/yi-ge-xiao-li-zi-zhu-ni-che-di-li-jie-xie-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="一个小例子助你彻底理解协程"><a href="#一个小例子助你彻底理解协程" class="headerlink" title="一个小例子助你彻底理解协程"></a>一个小例子助你彻底理解协程</h2><p>协程，可能是Python中最让初学者困惑的知识点之一，它也是Python中实现并发编程的一种重要方式。Python中可以使用多线程和多进程来实现并发，这两种方式相对来说是大家比较熟悉的。事实上，还有一种实现并发的方式叫做异步编程，而协程就是实现异步编程的必要方式。</p><p>所谓协程，可以简单的理解为多个相互协作的子程序。在同一个线程中，当一个子程序阻塞时，我们可以让程序马上从一个子程序切换到另一个子程序，从而避免CPU因程序阻塞而闲置，这样就可以提升CPU的利用率，相当于用一种协作的方式加速了程序的执行。所以，我们可以言简意赅的说：<strong>协程实现了协作式并发</strong>。</p><p>接下来用一个小例子帮助大家理解什么是协作式并发，先看看下面的代码。</p><pre class=" language-Python"><code class="language-Python">import timedef display(num):    time.sleep(1)    print(num)for num in range(10):    display(num)</code></pre><p>上面这段代码相信大家很容看懂，程序会输出0到9的数字，每隔1秒中输出一个数字，因此整个程序的执行需要大约10秒时间。值得注意的是，因为没有使用多线程或多进程，程序中只有一个执行单元，而<code>time.sleep(1)</code>的休眠操作会让整个线程停滞1秒钟，对于上面的代码来说，在这段时间里面CPU是完全闲置的没有做什么事情。</p><p>我们再来看看使用协程会发生什么事情。从Python 3.5开始，使用协程实现协作式编发有了更为便捷的语法，我们可以使用<code>async</code>来定义异步函数，可以使用<code>await</code>让一个阻塞的子程序将CPU让给与它协作的子程序。在Python 3.7中，<code>asyanc</code>和<code>await</code>成为了正式的关键字，让开发者有一种喜大普奔的感觉。我们先看看如何定义一个异步函数。</p><pre class=" language-Python"><code class="language-Python">import asyncioasync def display(num):    await asyncio.sleep(1)    print(num)</code></pre><p>接下来敲黑板说重点。异步函数不同于普通函数，调用普通函数会得到返回值，而调用异步函数会得到一个协程对象。我们需要将协程对象放到一个事件循环中才能达到与其他协程对象协作的效果，因为事件循环会负责处理子程序切换的操作，简单的说就是让阻塞的子程序让出CPU给可以执行的子程序。</p><p>我们先通过下面的列表生成式来代码10个协程对象，跟刚才在循环中调用display函数的道理一致。</p><pre class=" language-Python"><code class="language-Python">coroutines = [display(num) for num in range(10)]</code></pre><p>通过下面的代码可以获取事件循环并将协程对象放入事件循环中。</p><pre class=" language-Python"><code class="language-Python">loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(coroutines))loop.close()</code></pre><p>执行上面的代码会发现，10个分别会阻塞1秒钟的协程总共只阻塞了约1秒种的时间，这就说明<strong>协程对象一旦阻塞会将CPU让出而不是让CPU处于闲置状态</strong>，这样就大大的<strong>提升了CPU的利用率</strong>。而且我们还会注意到，0到9的数字并不是按照我们创建协程对象的顺序打印出来的，这正是我们想要的结果啊；另外，多次执行该程序会发现每次输出的结果都不太一样，这正是并发程序本身执行顺序不确定性造成的结果。</p><p>上面的例子来自于著名的“花书”（《Python高级并发编程》），为了让大家对协程的体会更加深刻，对原书的代码做了小的改动，这个例子虽然简单，但是它已经让你体会到了协作式并发的魅力。在商业项目中，如果需要使用协作式并发，还可以将系统默认的事件循环替换为<code>uvloop</code>提供的事件循环，这样会获得更好的性能，因为<code>uvloop</code>是基于著名的跨平台异步I/O库libuv实现的。另外，如果要做基于HTTP的网络编程，三方库<strong>aiohttp</strong>是不错的选择，它基于asyncio实现了异步的HTTP服务器和客户端。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系型数据库MySQL</title>
      <link href="/2020/06/15/mysql/guan-xi-xing-shu-ju-ku-mysql/"/>
      <url>/2020/06/15/mysql/guan-xi-xing-shu-ju-ku-mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="关系数据库入门"><a href="#关系数据库入门" class="headerlink" title="关系数据库入门"></a>关系数据库入门</h2><h3 id="关系数据库概述"><a href="#关系数据库概述" class="headerlink" title="关系数据库概述"></a>关系数据库概述</h3><ol><li><p>数据持久化 - 将数据保存到能够长久保存数据的存储介质中，在掉电的情况下数据也不会丢失。</p></li><li><p>数据库发展史 - 网状数据库、层次数据库、关系数据库、NoSQL数据库。</p><blockquote><p>1970年，IBM的研究员E.F.Codd在<em>Communication of the ACM</em>上发表了名为<em>A Relational Model of Data for Large Shared Data Banks</em>的论文，提出了关系模型的概念，奠定了关系模型的理论基础。后来Codd又陆续发表多篇文章，论述了范式理论和衡量关系系统的12条标准，用数学理论奠定了关系数据库的基础。</p></blockquote></li><li><p>关系数据库特点。</p><ul><li><p>理论基础：集合论和关系代数。</p></li><li><p>具体表象：用二维表（有行和列）组织数据。</p></li><li><p>编程语言：结构化查询语言（SQL）。</p></li></ul></li><li><p>ER模型（实体关系模型）和概念模型图。</p><p><strong>ER模型</strong>，全称为<strong>实体关系模型</strong>（Entity-Relationship Model），由美籍华裔计算机科学家陈品山先生提出，是概念数据模型的高层描述方式，如下图所示。</p><p><img src="./res/er_diagram.png" alt=""></p><ul><li>实体 - 矩形框</li><li>属性 - 椭圆框</li><li>关系 - 菱形框</li><li>重数 - 1:1（一对一） / 1:N（一对多） / M:N（多对多）</li></ul><p>实际项目开发中，我们可以利用数据库建模工具（如：PowerDesigner）来绘制概念数据模型（其本质就是ER模型），然后再设置好目标数据库系统，将概念模型转换成物理模型，最终生成创建二维表的SQL（很多工具都可以根据我们设计的物理模型图以及设定的目标数据库来导出SQL或直接生成数据表）。</p><p><img src="./res/conceptual_model.png" alt=""></p></li><li><p>关系数据库产品。</p><ul><li><a href="https://www.oracle.com/index.html" target="_blank" rel="noopener">Oracle</a> - 目前世界上使用最为广泛的数据库管理系统，作为一个通用的数据库系统，它具有完整的数据管理功能；作为一个关系数据库，它是一个完备关系的产品；作为分布式数据库，它实现了分布式处理的功能。在Oracle最新的12c版本中，还引入了多承租方架构，使用该架构可轻松部署和管理数据库云。</li><li><a href="https://www.ibm.com/analytics/us/en/db2/" target="_blank" rel="noopener">DB2</a> - IBM公司开发的、主要运行于Unix（包括IBM自家的<a href="https://zh.wikipedia.org/wiki/AIX" target="_blank" rel="noopener">AIX</a>）、Linux、以及Windows服务器版等系统的关系数据库产品。DB2历史悠久且被认为是最早使用SQL的数据库产品，它拥有较为强大的商业智能功能。</li><li><a href="https://www.microsoft.com/en-us/sql-server/" target="_blank" rel="noopener">SQL Server</a> - 由Microsoft开发和推广的关系型数据库产品，最初适用于中小企业的数据管理，但是近年来它的应用范围有所扩展，部分大企业甚至是跨国公司也开始基于它来构建自己的数据管理系统。</li><li><a href="https://www.mysql.com/" target="_blank" rel="noopener">MySQL</a> - MySQL是开放源代码的，任何人都可以在GPL（General Public License）的许可下下载并根据个性化的需要对其进行修改。MySQL因为其速度、可靠性和适应性而备受关注。</li><li><a href="">PostgreSQL</a> - 在BSD许可证下发行的开放源代码的关系数据库产品。</li></ul></li></ol><h3 id="MySQL简介"><a href="#MySQL简介" class="headerlink" title="MySQL简介"></a>MySQL简介</h3><p>MySQL最早是由瑞典的MySQL AB公司开发的一个开放源码的关系数据库管理系统，该公司于2008年被昇阳微系统公司（Sun Microsystems）收购。在2009年，甲骨文公司（Oracle）收购昇阳微系统公司，因此在这之后MySQL成为了Oracle旗下产品。</p><p>MySQL在过去由于性能高、成本低、可靠性好，已经成为最流行的开源数据库，因此被广泛地应用于中小型网站开发。随着MySQL的不断成熟，它也逐渐被应用于更多大规模网站和应用，比如维基百科、谷歌（Google）、脸书（Facebook）、淘宝网等网站都使用了MySQL来提供数据持久化服务。</p><p>甲骨文公司收购后昇阳微系统公司，大幅调涨MySQL商业版的售价，且甲骨文公司不再支持另一个自由软件项目<a href="https://zh.wikipedia.org/wiki/OpenSolaris" target="_blank" rel="noopener">OpenSolaris</a>的发展，因此导致自由软件社区对于Oracle是否还会持续支持MySQL社区版（MySQL的各个发行版本中唯一免费的版本）有所担忧，MySQL的创始人麦克尔·维德纽斯以MySQL为基础，成立分支计划<a href="https://zh.wikipedia.org/wiki/MariaDB" target="_blank" rel="noopener">MariaDB</a>（以他女儿的名字命名的数据库）。有许多原来使用MySQL数据库的公司（例如：维基百科）已经陆续完成了从MySQL数据库到MariaDB数据库的迁移。</p><ol><li><p>安装和配置</p><blockquote><p><strong>说明</strong>：下面的安装和配置都是以CentOS Linux环境为例，如果需要在其他系统下安装MySQL，读者可以自行在网络上查找对应的安装教程）。</p></blockquote><ul><li><p>刚才说过，MySQL有一个分支版本名叫MariaDB，该数据库旨在继续保持MySQL数据库在<a href="https://zh.wikipedia.org/wiki/GNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81" target="_blank" rel="noopener">GNU GPL</a>下开源。如果要使用MariaDB作为MySQL的替代品，可以使用下面的命令进行安装。</p><pre class=" language-Shell"><code class="language-Shell">yum install mariadb mariadb-server</code></pre></li><li><p>如果要安装官方版本的MySQL，可以在<a href="https://www.mysql.com/" target="_blank" rel="noopener">MySQL官方网站</a>下载安装文件。首先在下载页面中选择平台和版本，然后找到对应的下载链接。下面以MySQL 5.7.26版本和Red Hat Enterprise Linux为例，直接下载包含所有安装文件的归档文件，解归档之后通过包管理工具进行安装。</p><pre class=" language-Shell"><code class="language-Shell">wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tartar -xvf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar</code></pre><p>如果系统上有MariaDB相关的文件，需要先移除MariaDB相关的文件。</p><pre class=" language-Shell"><code class="language-Shell">yum list installed | grep mariadb | awk '{print $1}' | xargs yum erase -y</code></pre><p>接下来可以按照如下所示的顺序用RPM（Redhat Package Manager）工具安装MySQL。</p><pre class=" language-Shell"><code class="language-Shell">rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-compat-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-devel-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm</code></pre><p>可以使用下面的命令查看已经安装的MySQL相关的包。</p><pre class=" language-Shell"><code class="language-Shell">rpm -qa | grep mysql</code></pre></li><li><p>配置MySQL。</p><p>MySQL的配置文件在<code>/etc</code>目录下，名为<code>my.cnf</code>，默认的配置文件内容如下所示。如果对这个文件不理解并没有关系，什么时候用到这个配置文件什么时候再了解它就行了。</p><pre class=" language-Shell"><code class="language-Shell">cat /etc/my.cnf</code></pre><pre class=" language-INI"><code class="language-INI"># For advice on how to change settings please see# http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html[mysqld]## Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M## Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin## Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2Mdatadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid</code></pre></li><li><p>启动MySQL服务。</p><p>可以使用下面的命令来启动MySQL。</p><pre class=" language-Shell"><code class="language-Shell">service mysqld start</code></pre><p>在CentOS 7中，更推荐使用下面的命令来启动MySQL。</p><pre class=" language-Shell"><code class="language-Shell">systemctl start mysqld</code></pre><p>启动MySQL成功后，可以通过下面的命令来检查网络端口使用情况，MySQL默认使用3306端口。</p><pre class=" language-Shell"><code class="language-Shell">netstat -ntlp | grep mysql</code></pre><p>也可以使用下面的命令查找是否有名为mysqld的进程。</p><pre class=" language-Shell"><code class="language-Shell">pgrep mysqld</code></pre></li><li><p>使用MySQL客户端工具连接服务器。</p><p>命令行工具：</p><pre class=" language-Shell"><code class="language-Shell">mysql -u root -p</code></pre><blockquote><p>说明：启动客户端时，<code>-u</code>参数用来指定用户名，MySQL默认的超级管理账号为<code>root</code>；<code>-p</code>表示要输入密码（用户口令）；如果连接的是其他主机而非本机，可以用<code>-h</code>来指定连接主机的主机名或IP地址。</p></blockquote><p>如果是首次安装MySQL，可以使用下面的命令来找到默认的初始密码。</p><pre class=" language-Shell"><code class="language-Shell">cat /var/log/mysqld.log | grep password</code></pre><p>上面的命令会查看MySQL的日志带有password的行，在显示的结果中<code>root@localhost:</code>后面的部分就是默认设置的初始密码。</p><p>修改超级管理员（root）的访问口令为<code>123456</code>。</p><pre class=" language-SQL"><code class="language-SQL">set global validate_password_policy=0;set global validate_password_length=6;alter user 'root'@'localhost' identified by '123456';</code></pre><blockquote><p><strong>说明</strong>：MySQL较新的版本默认不允许使用弱口令作为用户口令，所以我们通过上面的前两条命令修改了验证用户口令的策略和口令的长度。事实上我们不应该使用弱口令，因为存在用户口令被暴力破解的风险。近年来，攻击数据库窃取数据和劫持数据库勒索比特币的事件屡见不鲜，要避免这些潜在的风险，最为重要的一点是不要让数据库服务器暴露在公网上（最好的做法是将数据库置于内网，至少要做到不向公网开放数据库服务器的访问端口），另外要保管好<code>root</code>账号的口令，应用系统需要访问数据库时，通常不使用<code>root</code>账号进行访问，而是创建其他拥有适当权限的账号来访问。</p></blockquote><p>再次使用客户端工具连接MySQL服务器时，就可以使用新设置的口令了。在实际开发中，为了方便用户操作，可以选择图形化的客户端工具来连接MySQL服务器，包括：</p><ul><li>MySQL Workbench（官方提供的工具）</li><li>Navicat for MySQL（界面简单优雅，功能直观强大）</li><li>SQLyog for MySQL（强大的MySQL数据库管理员工具）</li></ul></li></ul></li><li><p>常用命令。</p><ul><li><p>查看服务器版本。</p><pre class=" language-SQL"><code class="language-SQL">select version();</code></pre></li><li><p>查看所有数据库。</p><pre class=" language-SQL"><code class="language-SQL">show databases;</code></pre></li><li><p>切换到指定数据库。</p><pre class=" language-SQL"><code class="language-SQL">use mysql;</code></pre></li><li><p>查看数据库下所有表。</p><pre class=" language-Shell"><code class="language-Shell">show tables;</code></pre></li><li><p>获取帮助。</p><pre class=" language-SQL"><code class="language-SQL">? contents;? functions;? numeric functions;? round;? data types;? longblob;</code></pre></li></ul></li></ol><h3 id="SQL详解"><a href="#SQL详解" class="headerlink" title="SQL详解"></a>SQL详解</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>我们通常可以将SQL分为三类：DDL（数据定义语言）、DML（数据操作语言）和DCL（数据控制语言）。DDL主要用于创建（create）、删除（drop）、修改（alter）数据库中的对象，比如创建、删除和修改二维表；DML主要负责插入数据（insert）、删除数据（delete）、更新数据（update）和查询（select）；DCL通常用于授予权限（grant）和召回权限（revoke）。</p><blockquote><p>说明：SQL是不区分大小写的语言，为了书写方便，下面的SQL都使用了小写字母来书写。</p></blockquote><ol><li><p>DDL（数据定义语言）</p><pre class=" language-SQL"><code class="language-SQL">-- 如果存在名为school的数据库就删除它drop database if exists school;-- 创建名为school的数据库并设置默认的字符集和排序方式create database school default charset utf8;-- 切换到school数据库上下文环境use school;-- 创建学院表create table tb_college(collid         int auto_increment comment '编号',collname     varchar(50) not null comment '名称',collintro     varchar(500) default '' comment '介绍',primary key (collid));-- 创建学生表create table tb_student(stuid         int not null comment '学号',stuname     varchar(20) not null comment '姓名',stusex         boolean default 1 comment '性别',stubirth     date not null comment '出生日期',stuaddr     varchar(255) default '' comment '籍贯',collid         int not null comment '所属学院',primary key (stuid),foreign key (collid) references tb_college (collid));-- 创建教师表create table tb_teacher(teaid         int not null comment '工号',teaname     varchar(20) not null comment '姓名',teatitle     varchar(10) default '助教' comment '职称',collid         int not null comment '所属学院',primary key (teaid),foreign key (collid) references tb_college (collid));-- 创建课程表create table tb_course(couid         int not null comment '编号',couname     varchar(50) not null comment '名称',coucredit     int not null comment '学分',teaid         int not null comment '授课老师',primary key (couid),foreign key (teaid) references tb_teacher (teaid));-- 创建选课记录表create table tb_record(recid         int auto_increment comment '选课记录编号',sid         int not null comment '选课学生',cid         int not null comment '所选课程',seldate     datetime default now() comment '选课时间日期',score         decimal(4,1) comment '考试成绩',primary key (recid),foreign key (sid) references tb_student (stuid),foreign key (cid) references tb_course (couid),unique (sid, cid));</code></pre><p>上面的DDL有几个地方需要强调一下：</p><ul><li><p>创建数据库时，我们通过<code>default charset utf8</code>指定了数据库默认使用的字符集，我们推荐使用该字符集，因为utf8能够支持国际化编码。如果将来数据库中用到的字符可能包括类似于Emoji这样的图片字符，也可以将默认字符集设定为utf8mb4（最大4字节的utf-8编码）。查看MySQL支持的字符集可以执行下面的语句。</p><pre class=" language-SQL"><code class="language-SQL">show character set;</code></pre><pre><code>+----------+---------------------------------+---------------------+--------+| Charset  | Description                     | Default collation   | Maxlen |+----------+---------------------------------+---------------------+--------+| big5     | Big5 Traditional Chinese        | big5_chinese_ci     |      2 || dec8     | DEC West European               | dec8_swedish_ci     |      1 || cp850    | DOS West European               | cp850_general_ci    |      1 || hp8      | HP West European                | hp8_english_ci      |      1 || koi8r    | KOI8-R Relcom Russian           | koi8r_general_ci    |      1 || latin1   | cp1252 West European            | latin1_swedish_ci   |      1 || latin2   | ISO 8859-2 Central European     | latin2_general_ci   |      1 || swe7     | 7bit Swedish                    | swe7_swedish_ci     |      1 || ascii    | US ASCII                        | ascii_general_ci    |      1 || ujis     | EUC-JP Japanese                 | ujis_japanese_ci    |      3 || sjis     | Shift-JIS Japanese              | sjis_japanese_ci    |      2 || hebrew   | ISO 8859-8 Hebrew               | hebrew_general_ci   |      1 || tis620   | TIS620 Thai                     | tis620_thai_ci      |      1 || euckr    | EUC-KR Korean                   | euckr_korean_ci     |      2 || koi8u    | KOI8-U Ukrainian                | koi8u_general_ci    |      1 || gb2312   | GB2312 Simplified Chinese       | gb2312_chinese_ci   |      2 || greek    | ISO 8859-7 Greek                | greek_general_ci    |      1 || cp1250   | Windows Central European        | cp1250_general_ci   |      1 || gbk      | GBK Simplified Chinese          | gbk_chinese_ci      |      2 || latin5   | ISO 8859-9 Turkish              | latin5_turkish_ci   |      1 || armscii8 | ARMSCII-8 Armenian              | armscii8_general_ci |      1 || utf8     | UTF-8 Unicode                   | utf8_general_ci     |      3 || ucs2     | UCS-2 Unicode                   | ucs2_general_ci     |      2 || cp866    | DOS Russian                     | cp866_general_ci    |      1 || keybcs2  | DOS Kamenicky Czech-Slovak      | keybcs2_general_ci  |      1 || macce    | Mac Central European            | macce_general_ci    |      1 || macroman | Mac West European               | macroman_general_ci |      1 || cp852    | DOS Central European            | cp852_general_ci    |      1 || latin7   | ISO 8859-13 Baltic              | latin7_general_ci   |      1 || utf8mb4  | UTF-8 Unicode                   | utf8mb4_general_ci  |      4 || cp1251   | Windows Cyrillic                | cp1251_general_ci   |      1 || utf16    | UTF-16 Unicode                  | utf16_general_ci    |      4 || utf16le  | UTF-16LE Unicode                | utf16le_general_ci  |      4 || cp1256   | Windows Arabic                  | cp1256_general_ci   |      1 || cp1257   | Windows Baltic                  | cp1257_general_ci   |      1 || utf32    | UTF-32 Unicode                  | utf32_general_ci    |      4 || binary   | Binary pseudo charset           | binary              |      1 || geostd8  | GEOSTD8 Georgian                | geostd8_general_ci  |      1 || cp932    | SJIS for Windows Japanese       | cp932_japanese_ci   |      2 || eucjpms  | UJIS for Windows Japanese       | eucjpms_japanese_ci |      3 || gb18030  | China National Standard GB18030 | gb18030_chinese_ci  |      4 |+----------+---------------------------------+---------------------+--------+41 rows in set (0.00 sec)</code></pre><p>如果要设置MySQL服务启动时默认使用的字符集，可以修改MySQL的配置并添加以下内容</p><pre class=" language-INI"><code class="language-INI">[mysqld]character-set-server=utf8</code></pre></li><li><p>在创建表的时候，我们可以在右圆括号的后面通过<code>engine=XXX</code>来指定表的存储引擎，MySQL支持多种存储引擎，可以通过<code>show engines</code>命令进行查看。MySQL 5.5以后的版本默认使用的存储引擎是InnoDB，它正好也就是我们推荐大家使用的存储引擎（因为InnoDB更适合互联网应用对高并发、性能以及事务支持等方面的需求）。</p><pre class=" language-SQL"><code class="language-SQL">show engines\G</code></pre><pre><code>*************************** 1. row ***************************      Engine: InnoDB     Support: DEFAULT     Comment: Supports transactions, row-level locking, and foreign keysTransactions: YES          XA: YES  Savepoints: YES*************************** 2. row ***************************      Engine: MRG_MYISAM     Support: YES     Comment: Collection of identical MyISAM tablesTransactions: NO          XA: NO  Savepoints: NO*************************** 3. row ***************************      Engine: MEMORY     Support: YES     Comment: Hash based, stored in memory, useful for temporary tablesTransactions: NO          XA: NO  Savepoints: NO*************************** 4. row ***************************      Engine: BLACKHOLE     Support: YES     Comment: /dev/null storage engine (anything you write to it disappears)Transactions: NO          XA: NO  Savepoints: NO*************************** 5. row ***************************      Engine: MyISAM     Support: YES     Comment: MyISAM storage engineTransactions: NO          XA: NO  Savepoints: NO*************************** 6. row ***************************      Engine: CSV     Support: YES     Comment: CSV storage engineTransactions: NO          XA: NO  Savepoints: NO*************************** 7. row ***************************      Engine: ARCHIVE     Support: YES     Comment: Archive storage engineTransactions: NO          XA: NO  Savepoints: NO*************************** 8. row ***************************      Engine: PERFORMANCE_SCHEMA     Support: YES     Comment: Performance SchemaTransactions: NO          XA: NO  Savepoints: NO*************************** 9. row ***************************      Engine: FEDERATED     Support: NO     Comment: Federated MySQL storage engineTransactions: NULL          XA: NULL  Savepoints: NULL9 rows in set (0.00 sec)</code></pre><p>下面的表格对MySQL几种常用的数据引擎进行了简单的对比。</p><table><thead><tr><th>特性</th><th>InnoDB</th><th>MRG_MYISAM</th><th>MEMORY</th><th>MyISAM</th></tr></thead><tbody><tr><td>存储限制</td><td>有</td><td>没有</td><td>有</td><td>有</td></tr><tr><td>事务</td><td>支持</td><td></td><td></td><td></td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td></td></tr><tr><td>全文检索</td><td>支持（5.6+）</td><td></td><td></td><td>支持</td></tr><tr><td>集群索引</td><td>支持</td><td></td><td></td><td></td></tr><tr><td>数据缓存</td><td>支持</td><td></td><td>支持</td><td></td></tr><tr><td>索引缓存</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据可压缩</td><td></td><td></td><td></td><td>支持</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中</td><td>低</td></tr><tr><td>存储空间使用</td><td>高</td><td>低</td><td></td><td>低</td></tr><tr><td>批量插入性能</td><td>低</td><td>高</td><td>高</td><td>高</td></tr><tr><td>是否支持外键</td><td>支持</td><td></td><td></td><td></td></tr></tbody></table><p>通过上面的比较我们可以了解到，InnoDB是唯一能够支持外键、事务以及行锁的存储引擎，所以我们之前说它更适合互联网应用，而且它也是较新的MySQL版本中默认使用的存储引擎。</p></li><li><p>在定义表结构为每个字段选择数据类型时，如果不清楚哪个数据类型更合适，可以通过MySQL的帮助系统来了解每种数据类型的特性、数据的长度和精度等相关信息。</p><pre class=" language-SQL"><code class="language-SQL">? data types</code></pre><pre><code>You asked for help about help category: "Data Types"For more information, type 'help &lt;item&gt;', where &lt;item&gt; is one of the followingtopics:   AUTO_INCREMENT   BIGINT   BINARY   BIT   BLOB   BLOB DATA TYPE   BOOLEAN   CHAR   CHAR BYTE   DATE   DATETIME   DEC   DECIMAL   DOUBLE   DOUBLE PRECISION   ENUM   FLOAT   INT   INTEGER   LONGBLOB   LONGTEXT   MEDIUMBLOB   MEDIUMINT   MEDIUMTEXT   SET DATA TYPE   SMALLINT   TEXT   TIME   TIMESTAMP   TINYBLOB   TINYINT   TINYTEXT   VARBINARY   VARCHAR   YEAR DATA TYPE</code></pre><pre class=" language-SQL"><code class="language-SQL">? varchar</code></pre><pre><code>Name: 'VARCHAR'Description:[NATIONAL] VARCHAR(M) [CHARACTER SET charset_name] [COLLATEcollation_name]A variable-length string. M represents the maximum column length incharacters. The range of M is 0 to 65,535. The effective maximum lengthof a VARCHAR is subject to the maximum row size (65,535 bytes, which isshared among all columns) and the character set used. For example, utf8characters can require up to three bytes per character, so a VARCHARcolumn that uses the utf8 character set can be declared to be a maximumof 21,844 characters. Seehttp://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html.MySQL stores VARCHAR values as a 1-byte or 2-byte length prefix plusdata. The length prefix indicates the number of bytes in the value. AVARCHAR column uses one length byte if values require no more than 255bytes, two length bytes if values may require more than 255 bytes.*Note*:MySQL follows the standard SQL specification, and does not removetrailing spaces from VARCHAR values.VARCHAR is shorthand for CHARACTER VARYING. NATIONAL VARCHAR is thestandard SQL way to define that a VARCHAR column should use somepredefined character set. MySQL uses utf8 as this predefined characterset. http://dev.mysql.com/doc/refman/5.7/en/charset-national.html.NVARCHAR is shorthand for NATIONAL VARCHAR.URL: http://dev.mysql.com/doc/refman/5.7/en/string-type-overview.html</code></pre><p>在数据类型的选择上，保存字符串数据通常都使用VARCHAR和CHAR两种类型，前者通常称为变长字符串，而后者通常称为定长字符串；对于InnoDB存储引擎，行存储格式没有区分固定长度和可变长度列，因此VARCHAR类型好CHAR类型没有本质区别，后者不一定比前者性能更好。如果要保存的很大字符串，可以使用TEXT类型；如果要保存很大的字节串，可以使用BLOB（二进制大对象）类型。在MySQL中，TEXT和BLOB又分别包括TEXT、MEDIUMTEXT、LONGTEXT和BLOB、MEDIUMBLOB、LONGBLOB三种不同的类型，它们主要的区别在于存储数据的最大大小不同。保存浮点数可以用FLOAT或DOUBLE类型，而保存定点数应该使用DECIMAL类型。如果要保存时间日期，DATETIME类型优于TIMESTAMP类型，因为前者能表示的时间日期范围更大。</p></li></ul></li><li><p>DML</p><pre class=" language-SQL"><code class="language-SQL">-- 插入学院数据insert into tb_college (collname, collintro) values ('计算机学院', '创建于1956年是我国首批建立计算机专业。学院现有计算机科学与技术一级学科和网络空间安全一级学科博士学位授予权，其中计算机科学与技术一级学科具有博士后流动站。计算机科学与技术一级学科在2017年全国第四轮学科评估中评为A；2019 U.S.News全球计算机学科排名26名；ESI学科排名0.945‰，进入全球前1‰，位列第43位。'),('外国语学院', '1998年浙江大学、杭州大学、浙江农业大学、浙江医科大学四校合并，成立新的浙江大学。1999年原浙江大学外语系、原杭州大学外国语学院、原杭州大学大外部、原浙江农业大学公外部、原浙江医科大学外语教学部合并，成立浙江大学外国语学院。2003年学院更名为浙江大学外国语言文化与国际交流学院。'),('经济管理学院', '四川大学经济学院历史悠久、传承厚重，其前身是创办于1905年的四川大学经济科,距今已有100多年的历史。已故著名经济学家彭迪先、张与九、蒋学模、胡寄窗、陶大镛、胡代光，以及当代著名学者刘诗白等曾先后在此任教或学习。在长期的办学过程中，学院坚持以马克思主义的立场、观点、方法为指导，围绕建设世界一流经济学院的奋斗目标，做实“两个伟大”深度融合，不断提高党的建设质量与科学推进一流事业深度融合。');-- 插入学生数据insert into tb_student (stuid, stuname, stusex, stubirth, stuaddr, collid) values(1001, '杨逍', 1, '1990-3-4', '四川成都', 1),(1002, '任我行', 1, '1992-2-2', '湖南长沙', 1),(1033, '王语嫣', 0, '1989-12-3', '四川成都', 1),(1572, '岳不群', 1, '1993-7-19', '陕西咸阳', 1),(1378, '纪嫣然', 0, '1995-8-12', '四川绵阳', 1),(1954, '林平之', 1, '1994-9-20', '福建莆田', 1),(2035, '东方不败', 1, '1988-6-30', null, 2),(3011, '林震南', 1, '1985-12-12', '福建莆田', 3),(3755, '项少龙', 1, '1993-1-25', null, 3),(3923, '杨不悔', 0, '1985-4-17', '四川成都', 3),(4040, '隔壁老王', 1, '1989-1-1', '四川成都', 2);-- 删除学生数据delete from tb_student where stuid=4040;-- 更新学生数据update tb_student set stuname='杨过', stuaddr='湖南长沙' where stuid=1001;-- 插入老师数据insert into tb_teacher (teaid, teaname, teatitle, collid) values (1122, '张三丰', '教授', 1),(1133, '宋远桥', '副教授', 1),(1144, '杨逍', '副教授', 1),(2255, '范遥', '副教授', 2),(3366, '韦一笑', '讲师', 3);-- 插入课程数据insert into tb_course (couid, couname, coucredit, teaid) values (1111, 'Python程序设计', 3, 1122),(2222, 'Web前端开发', 2, 1122),(3333, '操作系统', 4, 1122),(4444, '计算机网络', 2, 1133),(5555, '编译原理', 4, 1144),(6666, '算法和数据结构', 3, 1144),(7777, '经贸法语', 3, 2255),(8888, '成本会计', 2, 3366),(9999, '审计学', 3, 3366);-- 插入选课数据insert into tb_record (sid, cid, seldate, score) values (1001, 1111, '2017-09-01', 95),(1001, 2222, '2017-09-01', 87.5),(1001, 3333, '2017-09-01', 100),(1001, 4444, '2018-09-03', null),(1001, 6666, '2017-09-02', 100),(1002, 1111, '2017-09-03', 65),(1002, 5555, '2017-09-01', 42),(1033, 1111, '2017-09-03', 92.5),(1033, 4444, '2017-09-01', 78),(1033, 5555, '2017-09-01', 82.5),(1572, 1111, '2017-09-02', 78),(1378, 1111, '2017-09-05', 82),(1378, 7777, '2017-09-02', 65.5),(2035, 7777, '2018-09-03', 88),(2035, 9999, default, null),(3755, 1111, default, null),(3755, 8888, default, null),(3755, 9999, '2017-09-01', 92);</code></pre><pre class=" language-SQL"><code class="language-SQL">-- 查询所有学生信息select * from tb_student;-- 查询所有课程名称及学分(投影和别名)select couname, coucredit from tb_course;select couname as 课程名称, coucredit as 学分 from tb_course;-- 查询所有学生的姓名和性别(条件运算)select stuname as 姓名, case stusex when 1 then '男' else '女' end as 性别 from tb_student;select stuname as 姓名, if(stusex, '男', '女') as 性别 from tb_student;-- 查询所有女学生的姓名和出生日期(筛选)select stuname, stubirth from tb_student where stusex=0;-- 查询所有80后学生的姓名、性别和出生日期(筛选)select stuname, stusex, stubirth from tb_student where stubirth>='1980-1-1' and stubirth<='1989-12-31';select stuname, stusex, stubirth from tb_student where stubirth between '1980-1-1' and '1989-12-31';-- 查询姓"杨"的学生姓名和性别(模糊)select stuname, stusex from tb_student where stuname like '杨%';-- 查询姓"杨"名字两个字的学生姓名和性别(模糊)select stuname, stusex from tb_student where stuname like '杨_';-- 查询姓"杨"名字三个字的学生姓名和性别(模糊)select stuname, stusex from tb_student where stuname like '杨__';-- 查询名字中有"不"字或"嫣"字的学生的姓名(模糊)select stuname, stusex from tb_student where stuname like '%不%' or stuname like '%嫣%';-- 查询没有录入家庭住址的学生姓名(空值)select stuname from tb_student where stuaddr is null;-- 查询录入了家庭住址的学生姓名(空值)select stuname from tb_student where stuaddr is not null;-- 查询学生选课的所有日期(去重)select distinct seldate from tb_record;-- 查询学生的家庭住址(去重)select distinct stuaddr from tb_student where stuaddr is not null;-- 查询男学生的姓名和生日按年龄从大到小排列(排序)select stuname as 姓名, datediff(curdate(), stubirth) div 365 as 年龄 from tb_student where stusex=1 order by 年龄 desc;-- 查询年龄最大的学生的出生日期(聚合函数)select min(stubirth) from tb_student;-- 查询年龄最小的学生的出生日期(聚合函数)select max(stubirth) from tb_student;-- 查询男女学生的人数(分组和聚合函数)select stusex, count(*) from tb_student group by stusex;-- 查询课程编号为1111的课程的平均成绩(筛选和聚合函数)select avg(score) from tb_record where cid=1111;-- 查询学号为1001的学生所有课程的平均分(筛选和聚合函数)select avg(score) from tb_record where sid=1001;-- 查询每个学生的学号和平均成绩(分组和聚合函数)select sid as 学号, avg(score) as 平均分 from tb_record group by sid;-- 查询平均成绩大于等于90分的学生的学号和平均成绩-- 分组以前的筛选使用where子句 / 分组以后的筛选使用having子句select sid as 学号, avg(score) as 平均分 from tb_record group by sid having 平均分>=90;-- 查询年龄最大的学生的姓名(子查询/嵌套的查询)select stuname from tb_student where stubirth=( select min(stubirth) from tb_student );-- 查询年龄最大的学生姓名和年龄(子查询+运算)select stuname as 姓名, datediff(curdate(), stubirth) div 365 as 年龄 from tb_student where stubirth=( select min(stubirth) from tb_student );-- 查询选了两门以上的课程的学生姓名(子查询/分组条件/集合运算)select stuname from tb_student where stuid in ( select stuid from tb_record group by stuid having count(stuid)>2 );-- 查询学生姓名、课程名称以及成绩(连接查询)select stuname, couname, score from tb_student t1, tb_course t2, tb_record t3 where stuid=sid and couid=cid and score is not null;-- 查询学生姓名、课程名称以及成绩按成绩从高到低查询第11-15条记录(内连接+分页)select stuname, couname, score from tb_student inner join tb_record on stuid=sid inner join tb_course on couid=cid where score is not null order by score desc limit 5 offset 10;select stuname, couname, score from tb_student inner join tb_record on stuid=sid inner join tb_course on couid=cid where score is not null order by score desc limit 10, 5;-- 查询选课学生的姓名和平均成绩(子查询和连接查询)select stuname, avgmark from tb_student, ( select sid, avg(score) as avgmark from tb_record group by sid ) temp where stuid=sid;select stuname, avgmark from tb_student inner join ( select sid, avg(score) as avgmark from tb_record group by sid ) temp on stuid=sid;-- 查询每个学生的姓名和选课数量(左外连接和子查询)select stuname, ifnull(total, 0) from tb_student left outer join ( select sid, count(sid) as total from tb_record group by sid ) temp on stuid=sid;</code></pre><p>上面的DML有几个地方需要加以说明：</p><ol><li><p>MySQL中支持多种类型的运算符，包括：算术运算符（+、-、*、/、%）、比较运算符（=、&lt;&gt;、&lt;=&gt;、&lt;、&lt;=、&gt;、&gt;=、BETWEEN…AND…、IN、IS NULL、IS NOT NULL、LIKE、RLIKE、REGEXP）、逻辑运算符（NOT、AND、OR、XOR）和位运算符（&amp;、|、^、~、&gt;&gt;、&lt;&lt;），我们可以在DML中使用这些运算符处理数据。</p></li><li><p>在查询数据时，可以在SELECT语句及其子句（如WHERE子句、ORDER BY子句、HAVING子句等）中使用函数，这些函数包括字符串函数、数值函数、时间日期函数、流程函数等，如下面的表格所示。</p><p>常用字符串函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT</td><td>将多个字符串连接成一个字符串</td></tr><tr><td>FORMAT</td><td>将数值格式化成字符串并指定保留几位小数</td></tr><tr><td>FROM_BASE64 / TO_BASE64</td><td>BASE64解码/编码</td></tr><tr><td>BIN / OCT / HEX</td><td>将数值转换成二进制/八进制/十六进制字符串</td></tr><tr><td>LOCATE</td><td>在字符串中查找一个子串的位置</td></tr><tr><td>LEFT / RIGHT</td><td>返回一个字符串左边/右边指定长度的字符</td></tr><tr><td>LENGTH / CHAR_LENGTH</td><td>返回字符串的长度以字节/字符为单位</td></tr><tr><td>LOWER / UPPER</td><td>返回字符串的小写/大写形式</td></tr><tr><td>LPAD / RPAD</td><td>如果字符串的长度不足，在字符串左边/右边填充指定的字符</td></tr><tr><td>LTRIM / RTRIM</td><td>去掉字符串前面/后面的空格</td></tr><tr><td>ORD / CHAR</td><td>返回字符对应的编码/返回编码对应的字符</td></tr><tr><td>STRCMP</td><td>比较字符串，返回-1、0、1分别表示小于、等于、大于</td></tr><tr><td>SUBSTRING</td><td>返回字符串指定范围的子串</td></tr></tbody></table><p>常用数值函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>ABS</td><td>返回一个数的绝度值</td></tr><tr><td>CEILING / FLOOR</td><td>返回一个数上取整/下取整的结果</td></tr><tr><td>CONV</td><td>将一个数从一种进制转换成另一种进制</td></tr><tr><td>CRC32</td><td>计算循环冗余校验码</td></tr><tr><td>EXP / LOG / LOG2 / LOG10</td><td>计算指数/对数</td></tr><tr><td>POW</td><td>求幂</td></tr><tr><td>RAND</td><td>返回[0,1)范围的随机数</td></tr><tr><td>ROUND</td><td>返回一个数四舍五入后的结果</td></tr><tr><td>SQRT</td><td>返回一个数的平方根</td></tr><tr><td>TRUNCATE</td><td>截断一个数到指定的精度</td></tr><tr><td>SIN / COS / TAN / COT / ASIN / ACOS / ATAN</td><td>三角函数</td></tr></tbody></table><p>常用时间日期函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE / CURTIME / NOW</td><td>获取当前日期/时间/日期和时间</td></tr><tr><td>ADDDATE / SUBDATE</td><td>将两个日期表达式相加/相减并返回结果</td></tr><tr><td>DATE / TIME</td><td>从字符串中获取日期/时间</td></tr><tr><td>YEAR / MONTH / DAY</td><td>从日期中获取年/月/日</td></tr><tr><td>HOUR / MINUTE / SECOND</td><td>从时间中获取时/分/秒</td></tr><tr><td>DATEDIFF / TIMEDIFF</td><td>返回两个时间日期表达式相差多少天/小时</td></tr><tr><td>MAKEDATE / MAKETIME</td><td>制造一个日期/时间</td></tr></tbody></table><p>常用流程函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF</td><td>根据条件是否成立返回不同的值</td></tr><tr><td>IFNULL</td><td>如果为NULL则返回指定的值否则就返回本身</td></tr><tr><td>NULLIF</td><td>两个表达式相等就返回NULL否则返回第一个表达式的值</td></tr></tbody></table><p>其他常用函数。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>MD5 / SHA1 / SHA2</td><td>返回字符串对应的哈希摘要</td></tr><tr><td>CHARSET / COLLATION</td><td>返回字符集/校对规则</td></tr><tr><td>USER / CURRENT_USER</td><td>返回当前用户</td></tr><tr><td>DATABASE</td><td>返回当前数据库名</td></tr><tr><td>VERSION</td><td>返回当前数据库版本</td></tr><tr><td>FOUND_ROWS / ROW_COUNT</td><td>返回查询到的行数/受影响的行数</td></tr><tr><td>LAST_INSERT_ID</td><td>返回最后一个自增主键的值</td></tr><tr><td>UUID / UUID_SHORT</td><td>返回全局唯一标识符</td></tr></tbody></table></li></ol></li><li><p>DCL</p><pre class=" language-SQL"><code class="language-SQL">-- 创建可以远程登录的root账号并为其指定口令create user 'root'@'%' identified by '123456';-- 为远程登录的root账号授权操作所有数据库所有对象的所有权限并允许其将权限再次赋予其他用户grant all privileges on *.* to 'root'@'%' with grant option;-- 创建名为hellokitty的用户并为其指定口令create user 'hellokitty'@'%' identified by '123123';-- 将对school数据库所有对象的所有操作权限授予hellokittygrant all privileges on school.* to 'hellokitty'@'%';-- 召回hellokitty对school数据库所有对象的insert/delete/update权限revoke insert, delete, update on school.* from 'hellokitty'@'%';</code></pre><blockquote><p>说明：创建一个可以允许任意主机登录并且具有超级管理员权限的用户在现实中并不是一个明智的决定，因为一旦该账号的口令泄露或者被破解，数据库将会面临灾难级的风险。</p></blockquote></li></ol><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>索引是关系型数据库中用来提升查询性能最为重要的手段。关系型数据库中的索引就像一本书的目录，我们可以想象一下，如果要从一本书中找出某个知识点，但是这本书没有目录，这将是意见多么可怕的事情（我们估计得一篇一篇的翻下去，才能确定这个知识点到底在什么位置）。创建索引虽然会带来存储空间上的开销，就像一本书的目录会占用一部分的篇幅一样，但是在牺牲空间后换来的查询时间的减少也是非常显著的。</p><p>MySQL中，所有数据类型的列都可以被索引，常用的存储引擎InnoDB和MyISAM能支持每个表创建16个索引。InnoDB和MyISAM使用的索引其底层算法是B-tree（B树），B-tree是一种自平衡的树，类似于平衡二叉排序树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的操作都在对数时间内完成。</p><p>接下来我们通过一个简单的例子来说明索引的意义，比如我们要根据学生的姓名来查找学生，这个场景在实际开发中应该经常遇到，就跟通过商品名称查找商品道理是一样的。我们可以使用MySQL的<code>explain</code>关键字来查看SQL的执行计划。</p><pre class=" language-SQL"><code class="language-SQL">explain select * from tb_student where stuname='林震南'\G</code></pre><pre><code>*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: tb_student   partitions: NULL         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 11     filtered: 10.00        Extra: Using where1 row in set, 1 warning (0.00 sec)</code></pre><p>在上面的SQL执行计划中，有几项值得我们关注：</p><ol><li>type：MySQL在表中找到满足条件的行的方式，也称为访问类型，包括：ALL（全表扫描）、index（索引全扫描）、range（索引范围扫描）、ref（非唯一索引扫描）、eq_ref（唯一索引扫描）、const/system、NULL。在所有的访问类型中，很显然ALL是性能最差的，它代表了全表扫描是指要扫描表中的每一行才能找到匹配的行。</li><li>possible_keys：MySQL可以选择的索引，但是<strong>有可能不会使用</strong>。</li><li>key：MySQL真正使用的索引。</li><li>rows：执行查询需要扫描的行数，这是一个<strong>预估值</strong>。</li></ol><p>从上面的执行计划可以看出，当我们通过学生名字查询学生时实际上是进行了全表扫描，不言而喻这个查询性能肯定是非常糟糕的，尤其是在表中的行很多的时候。如果我们需要经常通过学生姓名来查询学生，那么就应该在学生姓名对应的列上创建索引，通过索引来加速查询。</p><pre class=" language-SQL"><code class="language-SQL">create index idx_student_name on tb_student(stuname);</code></pre><p>再次查看刚才的SQL对应的执行计划。</p><pre class=" language-SQL"><code class="language-SQL">explain select * from tb_student where stuname='林震南'\G</code></pre><pre><code>*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: tb_student   partitions: NULL         type: refpossible_keys: idx_student_name          key: idx_student_name      key_len: 62          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><p>可以注意到，在对学生姓名创建索引后，刚才的查询已经不是全表扫描而是基于索引的查询，而且扫描的行只有唯一的一行，这显然大大的提升了查询的性能。MySQL中还允许创建前缀索引，即对索引字段的前N个字符创建索引，这样的话可以减少索引占用的空间（但节省了空间很有可能会浪费时间，<strong>时间和空间是不可调和的矛盾</strong>），如下所示。</p><pre class=" language-SQL"><code class="language-SQL">create index idx_student_name_1 on tb_student(stuname(1));</code></pre><p>上面的索引相当于是根据学生姓名的第一个字来创建的索引，我们再看看SQL执行计划。</p><pre class=" language-SQL"><code class="language-SQL">explain select * from tb_student where stuname='林震南'\G</code></pre><pre><code>*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: tb_student   partitions: NULL         type: refpossible_keys: idx_student_name          key: idx_student_name      key_len: 5          ref: const         rows: 2     filtered: 100.00        Extra: Using where1 row in set, 1 warning (0.00 sec)</code></pre><p>不知道大家是否注意到，这一次扫描的行变成了2行，因为学生表中有两个姓“林”的学生，我们只用姓名的第一个字作为索引的话，在查询时通过索引就会找到这两行。</p><p>如果要删除索引，可以使用下面的SQL。</p><pre class=" language-SQL"><code class="language-SQL">alter table tb_student drop index idx_student_name;</code></pre><p>或者</p><pre class=" language-SQL"><code class="language-SQL">drop index idx_student_name on tb_student;</code></pre><p>我们简单的为大家总结一下索引的设计原则：</p><ol><li><strong>最适合</strong>索引的列是出现在<strong>WHERE子句</strong>和连接子句中的列。</li><li>索引列的基数越大（取值多重复值少），索引的效果就越好。</li><li>使用<strong>前缀索引</strong>可以减少索引占用的空间，内存中可以缓存更多的索引。</li><li><strong>索引不是越多越好</strong>，虽然索引加速了读操作（查询），但是写操作（增、删、改）都会变得更慢，因为数据的变化会导致索引的更新，就如同书籍章节的增删需要更新目录一样。</li><li>使用InnoDB存储引擎时，表的普通索引都会保存主键的值，所以<strong>主键要尽可能选择较短的数据类型</strong>，这样可以有效的减少索引占用的空间，利用提升索引的缓存效果。</li></ol><p>最后，还有一点需要说明，InnoDB使用的B-tree索引，数值类型的列除了等值判断时索引会生效之外，使用&gt;、&lt;、&gt;=、&lt;=、BETWEEN…AND… 、&lt;&gt;时，索引仍然生效；对于字符串类型的列，如果使用不以通配符开头的模糊查询，索引也是起作用的，但是其他的情况会导致索引失效，这就意味着很有可能会做全表查询。</p><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>视图是关系型数据库中将一组查询指令构成的结果集组合成可查询的数据表的对象。简单的说，视图就是虚拟的表，但与数据表不同的是，数据表是一种实体结构，而视图是一种虚拟结构，你也可以将视图理解为保存在数据库中被赋予名字的SQL语句。</p><p>使用视图可以获得以下好处：</p><ol><li>可以将实体数据表隐藏起来，让外部程序无法得知实际的数据结构，让访问者可以使用表的组成部分而不是整个表，降低数据库被攻击的风险。</li><li>在大多数的情况下视图是只读的（更新视图的操作通常都有诸多的限制），外部程序无法直接透过视图修改数据。</li><li>重用SQL语句，将高度复杂的查询包装在视图表中，直接访问该视图即可取出需要的数据；也可以将视图视为数据表进行连接查询。</li><li>视图可以返回与实体数据表不同格式的数据，</li></ol><p>创建视图。</p><pre class=" language-SQL"><code class="language-SQL">create view vw_avg_score as     select sid, round(avg(score), 1) as avgscore     from tb_record group by sid;create view vw_student_score as     select stuname, avgscore     from tb_student, vw_avg_score     where stuid=sid;</code></pre><blockquote><p><strong>提示</strong>：因为视图不包含数据，所以每次使用视图时，都必须执行查询以获得数据，如果你使用了连接查询、嵌套查询创建了较为复杂的视图，你可能会发现查询性能下降得很厉害。因此，在使用复杂的视图前，应该进行测试以确保其性能能够满足应用的需求。</p></blockquote><p>使用视图。</p><pre class=" language-SQL"><code class="language-SQL">select stuname, avgscore from vw_student_score order by avgscore desc;</code></pre><pre><code>+--------------+----------+| stuname      | avgscore |+--------------+----------+| 杨过         |     95.6 || 任我行       |     53.5 || 王语嫣       |     84.3 || 纪嫣然       |     73.8 || 岳不群       |     78.0 || 东方不败     |     88.0 || 项少龙       |     92.0 |+--------------+----------+</code></pre><p>既然视图是一张虚拟的表，那么视图的中的数据可以更新吗？视图的可更新性要视具体情况而定，以下类型的视图是不能更新的：</p><ol><li>使用了聚合函数（SUM、MIN、MAX、AVG、COUNT等）、DISTINCT、GROUP BY、HAVING、UNION或者UNION ALL的视图。</li><li>SELECT中包含了子查询的视图。</li><li>FROM子句中包含了一个不能更新的视图的视图。</li><li>WHERE子句的子查询引用了FROM子句中的表的视图。</li></ol><p>删除视图。</p><pre class=" language-SQL"><code class="language-SQL">drop view vw_student_score;</code></pre><blockquote><p><strong>说明</strong>：如果希望更新视图，可以先用上面的命令删除视图，也可以通过<code>create or replace view</code>来更新视图。</p></blockquote><p>视图的规则和限制。</p><ol><li>视图可以嵌套，可以利用从其他视图中检索的数据来构造一个新的视图。视图也可以和表一起使用。</li><li>创建视图时可以使用<code>order by</code>子句，但如果从视图中检索数据时也使用了<code>order by</code>，那么该视图中原先的<code>order by</code>会被覆盖。</li><li>视图无法使用索引，也不会激发触发器（实际开发中因为性能等各方面的考虑，通常不建议使用触发器，所以我们也不对这个概念进行介绍）的执行。</li></ol><h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><p>存储过程是事先编译好存储在数据库中的一组SQL的集合，调用存储过程可以简化应用程序开发人员的工作，减少与数据库服务器之间的通信，对于提升数据操作的性能也是有帮助的。其实迄今为止，我们使用的SQL语句都是针对一个或多个表的单条语句，但在实际开发中经常会遇到某个操作需要多条SQL语句才能完成的情况。例如，电商网站在受理用户订单时，需要做以下一系列的处理。 </p><ol><li>通过查询来核对库存中是否有对应的物品以及库存是否充足。</li><li>如果库存有物品，需要锁定库存以确保这些物品不再卖给别人， 并且要减少可用的物品数量以反映正确的库存量。</li><li>如果库存不足，可能需要进一步与供应商进行交互或者至少产生一条系统提示消息。 </li><li>不管受理订单是否成功，都需要产生流水记录，而且需要给对应的用户产生一条通知信息。 </li></ol><p>我们可以通过存储过程将复杂的操作封装起来，这样不仅有助于保证数据的一致性，而且将来如果业务发生了变动，只需要调整和修改存储过程即可。对于调用存储过程的用户来说，存储过程并没有暴露数据表的细节，而且执行存储过程比一条条的执行一组SQL要快得多。</p><p>下面的存储过程实现了查询某门课程的最高分、最低分和平均分。</p><pre class=" language-SQL"><code class="language-SQL">drop procedure if exists sp_score_by_cid;delimiter $$create procedure sp_score_by_cid(    courseId int,     out maxScore decimal(4,1),     out minScore decimal(4,1),    out avgScore decimal(4,1))begin    select max(score) into maxScore from tb_record         where cid=courseId;    select min(score) into minScore from tb_record         where cid=courseId;    select avg(score) into avgScore from tb_record         where cid=courseId;end $$delimiter ;call sp_score_by_cid(1111, @a, @b, @c);select @a, @b, @c;</code></pre><blockquote><p>说明：在定义存储过程时，因为可能需要书写多条SQL，而分隔这些SQL需要使用分号作为分隔符，如果这个时候，仍然用分号表示整段代码结束，那么定义存储过程的SQL就会出现错误，所以上面我们用<code>delimiter $$</code>将整段代码结束的标记定义为<code>$$</code>，那么代码中的分号将不再表示整段代码的结束，需要马上执行，整段代码在遇到<code>end $$</code>时才输入完成并执行。在定义完存储过程后，通过<code>delimiter ;</code>将结束符重新改回成分号。</p></blockquote><p>上面定义的存储过程有四个参数，其中第一个参数是输入参数，代表课程的编号，后面的参数都是输出参数，因为存储过程不能定义返回值，只能通过输出参数将执行结果带出，定义输出参数的关键字是<code>out</code>，默认情况下参数都是输入参数。</p><p>调用存储过程。</p><pre class=" language-SQL"><code class="language-SQL">call sp_score_by_cid(1111, @a, @b, @c);</code></pre><p>获取输出参数的值。</p><pre class=" language-SQL"><code class="language-SQL">select @a as 最高分, @b as 最低分, @c as 平均分;</code></pre><p>删除存储过程。</p><pre class=" language-SQL"><code class="language-SQL">drop procedure sp_score_by_cid;</code></pre><p>在存储过程中，我们可以定义变量、条件，可以使用分支和循环语句，可以通过游标操作查询结果，还可以使用事件调度器，这些内容我们暂时不在此处进行介绍。虽然我们说了很多存储过程的好处，但是在实际开发中，如果过度的使用存储过程，将大量复杂的运算放到存储过程中，也会导致占用数据库服务器的CPU资源，造成数据库服务器承受巨大的压力。为此，我们一般会将复杂的运算和处理交给应用服务器，因为很容易部署多台应用服务器来分摊这些压力。</p><h3 id="几个重要的概念"><a href="#几个重要的概念" class="headerlink" title="几个重要的概念"></a>几个重要的概念</h3><h4 id="范式理论-设计二维表的指导思想"><a href="#范式理论-设计二维表的指导思想" class="headerlink" title="范式理论 - 设计二维表的指导思想"></a>范式理论 - 设计二维表的指导思想</h4><ol><li>第一范式：数据表的每个列的值域都是由原子值组成的，不能够再分割。</li><li>第二范式：数据表里的所有数据都要和该数据表的键（主键与候选键）有完全依赖关系。</li><li>第三范式：所有非键属性都只和候选键有相关性，也就是说非键属性之间应该是独立无关的。</li></ol><h4 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h4><ol><li><p>实体完整性 - 每个实体都是独一无二的</p><ul><li>主键（primary key） / 唯一约束 / 唯一索引（unique）</li></ul></li><li><p>引用完整性（参照完整性）- 关系中不允许引用不存在的实体</p><ul><li>外键（foreign key）</li></ul></li><li><p>域完整性 - 数据是有效的</p><ul><li><p>数据类型及长度</p></li><li><p>非空约束（not null）</p></li><li><p>默认值约束（default）</p></li><li><p>检查约束（check）</p><blockquote><p>说明：在MySQL数据库中，检查约束并不起作用。</p></blockquote></li></ul></li></ol><h4 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h4><ol><li><p>事务：一系列对数据库进行读/写的操作，这些操作要么全都成功，要么全都失败。</p></li><li><p>事务的ACID特性</p><ul><li>原子性：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行</li><li>一致性：事务应确保数据库的状态从一个一致状态转变为另一个一致状态</li><li>隔离性：多个事务并发执行时，一个事务的执行不应影响其他事务的执行</li><li>持久性：已被提交的事务对数据库的修改应该永久保存在数据库中</li></ul></li><li><p>MySQL中的事务操作</p><ul><li><p>开启事务环境</p><pre class=" language-SQL"><code class="language-SQL">start transaction</code></pre><p>或</p><pre class=" language-SQL"><code class="language-SQL">begin</code></pre></li><li><p>提交事务</p><pre class=" language-SQL"><code class="language-SQL">commit</code></pre></li><li><p>回滚事务</p><pre class=" language-SQL"><code class="language-SQL">rollback</code></pre></li></ul></li></ol><h3 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h3><p>大家应该能够想到，关于MySQL的知识肯定远远不止上面列出的这些，比如MySQL的性能优化、管理和维护MySQL的相关工具、MySQL数据的备份和恢复、监控MySQL、部署高可用架构等问题我们在这里都没有进行讨论。当然，这些内容也都是跟项目开发密切相关的，我们就留到后续的章节中再续点进行讲解。</p><h3 id="Python数据库编程"><a href="#Python数据库编程" class="headerlink" title="Python数据库编程"></a>Python数据库编程</h3><p>我们用如下所示的数据库来演示在Python中如何访问MySQL数据库。</p><pre class=" language-SQL"><code class="language-SQL">drop database if exists hrs;create database hrs default charset utf8;use hrs;drop table if exists tb_emp;drop table if exists tb_dept;create table tb_dept(dno   int not null comment '编号',dname varchar(10) not null comment '名称',dloc  varchar(20) not null comment '所在地',primary key (dno));insert into tb_dept values     (10, '会计部', '北京'),    (20, '研发部', '成都'),    (30, '销售部', '重庆'),    (40, '运维部', '深圳');create table tb_emp(eno   int not null comment '员工编号',ename varchar(20) not null comment '员工姓名',job   varchar(20) not null comment '员工职位',mgr   int comment '主管编号',sal   int not null comment '员工月薪',comm  int comment '每月补贴',dno   int comment '所在部门编号',primary key (eno));alter table tb_emp add constraint fk_emp_dno foreign key (dno) references tb_dept (dno);insert into tb_emp values     (7800, '张三丰', '总裁', null, 9000, 1200, 20),    (2056, '乔峰', '分析师', 7800, 5000, 1500, 20),    (3088, '李莫愁', '设计师', 2056, 3500, 800, 20),    (3211, '张无忌', '程序员', 2056, 3200, null, 20),    (3233, '丘处机', '程序员', 2056, 3400, null, 20),    (3251, '张翠山', '程序员', 2056, 4000, null, 20),    (5566, '宋远桥', '会计师', 7800, 4000, 1000, 10),    (5234, '郭靖', '出纳', 5566, 2000, null, 10),    (3344, '黄蓉', '销售主管', 7800, 3000, 800, 30),    (1359, '胡一刀', '销售员', 3344, 1800, 200, 30),    (4466, '苗人凤', '销售员', 3344, 2500, null, 30),    (3244, '欧阳锋', '程序员', 3088, 3200, null, 20),    (3577, '杨过', '会计', 5566, 2200, null, 10),    (3588, '朱九真', '会计', 5566, 2500, null, 10);</code></pre><p>在Python 3中，我们通常使用纯Python的三方库PyMySQL来访问MySQL数据库，它应该是目前Python操作MySQL数据库最好的选择。</p><ol><li><p>安装PyMySQL。</p><pre class=" language-Shell"><code class="language-Shell">pip install pymysql</code></pre></li><li><p>添加一个部门。</p><pre class=" language-Python"><code class="language-Python">import pymysql</code></pre></li></ol><p>   def main():<br>       no = int(input(‘编号: ‘))<br>       name = input(‘名字: ‘)<br>       loc = input(‘所在地: ‘)<br>       # 1. 创建数据库连接对象<br>       con = pymysql.connect(host=’localhost’, port=3306,<br>                             database=’hrs’, charset=’utf8’,<br>                             user=’yourname’, password=’yourpass’)<br>       try:<br>           # 2. 通过连接对象获取游标<br>           with con.cursor() as cursor:<br>               # 3. 通过游标执行SQL并获得执行结果<br>               result = cursor.execute(<br>                   ‘insert into tb_dept values (%s, %s, %s)’,<br>                   (no, name, loc)<br>               )<br>           if result == 1:<br>               print(‘添加成功!’)<br>           # 4. 操作成功提交事务<br>           con.commit()<br>       finally:<br>           # 5. 关闭连接释放资源<br>           con.close()</p><p>   if <strong>name</strong> == ‘<strong>main</strong>‘:<br>       main()</p><pre><code>3. 删除一个部门。   ```Python   import pymysql   def main():       no = int(input('编号: '))       con = pymysql.connect(host='localhost', port=3306,                             database='hrs', charset='utf8',                             user='yourname', password='yourpass',                             autocommit=True)       try:           with con.cursor() as cursor:               result = cursor.execute(                   'delete from tb_dept where dno=%s',                   (no, )               )           if result == 1:               print('删除成功!')       finally:           con.close()   if __name__ == '__main__':       main()</code></pre><blockquote><p>说明：如果不希望每次SQL操作之后手动提交或回滚事务，可以像上面的代码那样，在创建连接的时候多加一个名为<code>autocommit</code>的参数并将它的值设置为<code>True</code>，表示每次执行SQL之后自动提交。如果程序中不需要使用事务环境也不希望手动的提交或回滚就可以这么做。</p></blockquote><ol start="4"><li><p>更新一个部门。</p><pre class=" language-Python"><code class="language-Python">import pymysql</code></pre></li></ol><p>   def main():<br>       no = int(input(‘编号: ‘))<br>       name = input(‘名字: ‘)<br>       loc = input(‘所在地: ‘)<br>       con = pymysql.connect(host=’localhost’, port=3306,<br>                             database=’hrs’, charset=’utf8’,<br>                             user=’yourname’, password=’yourpass’,<br>                             autocommit=True)<br>       try:<br>           with con.cursor() as cursor:<br>               result = cursor.execute(<br>                   ‘update tb_dept set dname=%s, dloc=%s where dno=%s’,<br>                   (name, loc, no)<br>               )<br>           if result == 1:<br>               print(‘更新成功!’)<br>       finally:<br>           con.close()</p><p>   if <strong>name</strong> == ‘<strong>main</strong>‘:<br>       main()</p><pre><code>5. 查询所有部门。   ```Python   import pymysql   from pymysql.cursors import DictCursor   def main():       con = pymysql.connect(host='localhost', port=3306,                             database='hrs', charset='utf8',                             user='yourname', password='yourpass')       try:           with con.cursor(cursor=DictCursor) as cursor:               cursor.execute('select dno as no, dname as name, dloc as loc from tb_dept')               results = cursor.fetchall()               print(results)               print('编号\t名称\t\t所在地')               for dept in results:                   print(dept['no'], end='\t')                   print(dept['name'], end='\t')                   print(dept['loc'])       finally:           con.close()   if __name__ == '__main__':       main()</code></pre><ol start="6"><li><p>分页查询员工信息。</p><pre class=" language-Python"><code class="language-Python">import pymysqlfrom pymysql.cursors import DictCursor</code></pre></li></ol><p>   class Emp(object):</p><pre><code>   def __init__(self, no, name, job, sal):       self.no = no       self.name = name       self.job = job       self.sal = sal   def __str__(self):       return f'\n编号：{self.no}\n姓名：{self.name}\n职位：{self.job}\n月薪：{self.sal}\n'</code></pre><p>   def main():<br>       page = int(input(‘页码: ‘))<br>       size = int(input(‘大小: ‘))<br>       con = pymysql.connect(host=’localhost’, port=3306,<br>                             database=’hrs’, charset=’utf8’,<br>                             user=’yourname’, password=’yourpass’)<br>       try:<br>           with con.cursor() as cursor:<br>               cursor.execute(<br>                   ‘select eno as no, ename as name, job, sal from tb_emp limit %s,%s’,<br>                   ((page - 1) * size, size)<br>               )<br>               for emp_tuple in cursor.fetchall():<br>                   emp = Emp(*emp_tuple)<br>                   print(emp)<br>       finally:<br>           con.close()</p><p>   if <strong>name</strong> == ‘<strong>main</strong>‘:<br>       main()</p><pre><code></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转PyCharm</title>
      <link href="/2020/06/12/ruan-jian-gong-ju/wan-zhuan-pycharm/"/>
      <url>/2020/06/12/ruan-jian-gong-ju/wan-zhuan-pycharm/</url>
      
        <content type="html"><![CDATA[<h2 id="玩转PyCharm"><a href="#玩转PyCharm" class="headerlink" title="玩转PyCharm"></a>玩转PyCharm</h2><p>PyCharm是由JetBrains公司开发的提供给Python专业的开发者的一个集成开发环境，它最大的优点是能够大大提升Python开发者的工作效率，为开发者集成了很多用起来非常顺手的功能，包括代码调试、高亮语法、代码跳转、智能提示、自动补全、单元测试、版本控制等等。此外，PyCharm还提供了对一些高级功能的支持，包括支持基于Django框架的Web开发。</p><h3 id="PyCharm的下载和安装"><a href="#PyCharm的下载和安装" class="headerlink" title="PyCharm的下载和安装"></a>PyCharm的下载和安装</h3><p>可以在<a href="https://www.jetbrains.com/" target="_blank" rel="noopener">JetBrains公司的官方网站</a>找到PyCharm的<a href="https://www.jetbrains.com/pycharm/download/" target="_blank" rel="noopener">下载链接</a>，有两个可供下载的版本，一个是社区版（PyCharm CE），一个是专业版（PyCharm Professional）。社区版在Apache许可证下发布，可以免费使用；专业版在专用许可证下发布，需要购买授权后才能使用，但新用户可以试用30天。很显然，专业版提供了更为强大的功能和对企业级开发的各种支持，但是对于初学者来说，社区版已经足够强大和好用了。安装PyCharm只需要直接运行下载的安装程序，然后持续的点击“Next”（下一步）按钮就可以啦。下面是我在Windows系统下安装PyCharm的截图，安装完成后点击“Finish”（结束）按钮关闭安装向导，然后可以通过双击桌面的快捷方式来运行PyCharm。</p><h3 id="首次使用的设置"><a href="#首次使用的设置" class="headerlink" title="首次使用的设置"></a>首次使用的设置</h3><p>第一次使用PyCharm时，会有一个导入设置的向导，如果之前没有使用PyCharm或者没有保存过设置的就直接选择“Do not import settings”进入下一步即可，下面是我在macOS系统下第一次使用PyCharm时的截图。</p><p>专业版的PyCharm是需要激活的，<strong>强烈建议大家在条件允许的情况下支付费用来支持优秀的产品</strong>，如果不用做商业用途或者不需要使用PyCharm的高级功能，我们可以暂时选择试用30天或者使用社区版的PyCharm。如果你是一名学生，希望购买PyCharm来使用，可以看看<a href="https://sales.jetbrains.com/hc/zh-cn/articles/207154369" target="_blank" rel="noopener">教育优惠官方申请指南</a>。如下图所示，我们需要点击“Evaluate”按钮来试用专业版PyCharm。</p><p>接下来是选择UI主题，可以根据个人喜好进行选择，深色的主题比较护眼而浅色的主题对比度更好。</p><p>再接下来是创建可以在“终端”或“命令行提示符”中运行PyCharm的启动脚本，当然也可以不做任何勾选，直接点击“Next: Featured plugins”按钮进入下一环节。</p><p>然后可以选择需要安装哪些插件，我们可以暂时什么都不安装，等需要的时候再来决定。</p><h3 id="用PyCharm创建项目"><a href="#用PyCharm创建项目" class="headerlink" title="用PyCharm创建项目"></a>用PyCharm创建项目</h3><p>启动PyCharm之后会来到一个欢迎页，在欢迎页上我们可以选择“创建新项目”（Create New Project）、“打开已有项目”（Open）和“从版本控制系统中检出项目”（Get from Version Control）。</p><p>如果选择了“Create New Project”来创建新项目就会打一个创建项目的向导页。下图所示是PyCharm专业版创建新项目的向导页，可以看出专业版支持的项目类型非常的多，而社区版只能创建纯Python项目（Pure Python），没有这一系列的选项。</p><p>接下来，我们要为项目创建专属的虚拟环境，每个Python项目最好都在自己专属的虚拟环境中运行，因为每个项目对Python解释器和三方库的需求并不相同，虚拟环境对不同的项目进行了隔离。在上图所示的界面在，我们可以选择新建虚拟环境（New environment using Virtualenv），这里的“Virtualenv”是PyCharm默认选择的创建虚拟环境的工具，我们就保留这个默认的选项就可以了。</p><p>项目创建完成后就可以开始新建各种文件来书写Python代码了，如下图所示。左侧是项目浏览器，可以看到刚才创建的项目文件夹以及虚拟环境文件夹。我们可以在项目上点击鼠标右键，选择“New”，在选择“Python File”来创建Python代码文件，下图中我们创建了两个Python文件，分别是<code>poker_game.py</code>和<code>salary_system.py</code>。当然，如果愿意，也可以使用复制粘贴的方式把其他地方的Python代码文件复制到项目文件夹下。</p><p>在工作窗口点击鼠标右键可以在上下文菜单中找到“Run”选项，例如要运行<code>salary_system.py</code>文件，右键菜单会显示“Run ‘salary_system’”选项，点击这个选项我们就可以运行Python代码啦，运行结果在屏幕下方的窗口可以看到，如下图所示。</p><h3 id="常用操作和快捷键"><a href="#常用操作和快捷键" class="headerlink" title="常用操作和快捷键"></a>常用操作和快捷键</h3><p>PyCharm为写Python代码提供了自动补全和高亮语法功能，这也是PyCharm作为集成开发环境（IDE）的基本功能。PyCharm的“File”菜单有一个“Settings”菜单项（macOS上是在“PyCharm”菜单的“Preferences…”菜单项），这个菜单项会打开设置窗口，可以在此处对PyCharm进行设置，如下图所示。</p><p>PyCharm的菜单项中有一个非常有用的“Code”菜单，菜单中提供了自动生成代码、自动补全代码、格式化代码、移动代码等选项，这些功能对开发者来说是非常有用的，大家可以尝试使用这些菜单项或者记住它们对应的快捷键，例如在macOS上，格式化代码这个菜单项对应的快捷键是<code>alt+command+L</code>。除此之外，“Refactor”菜单也非常有用，它提供了一些重构代码的选项。所谓重构是在不改变代码执行结果的前提下调整代码的结构，这也是资深程序员的一项重要技能。还有一个值得一提的菜单是“VCS”，VCS是“Version Control System”（版本控制系统）的缩写，这个菜单提供了对代码版本管理的支持。版本控制的知识会在其他的课程中为大家讲解。</p><p>下表列出了一些PyCharm中特别常用的快捷键，当然如果愿意，也可以通过设置窗口中“Keymap”菜单项自定义快捷键，PyCharm本身也针对不同的操作系统和使用习惯对快捷键进行了分组。</p><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td><code>command + j</code></td><td>显示可用的代码模板</td></tr><tr><td><code>command + b</code></td><td>查看函数、类、方法的定义</td></tr><tr><td><code>ctrl + space</code></td><td>万能代码提示快捷键，一下不行按两下</td></tr><tr><td><code>command + alt + l</code></td><td>格式化代码</td></tr><tr><td><code>alt + enter</code></td><td>万能代码修复快捷键</td></tr><tr><td><code>ctrl + /</code></td><td>注释/反注释代码</td></tr><tr><td><code>shift + shift</code></td><td>万能搜索快捷键</td></tr><tr><td><code>command + d</code> / <code>command + y</code></td><td>复制/删除一行代码</td></tr><tr><td><code>command + shift + -</code> / <code>command + shift + +</code></td><td>折叠/展开所有代码</td></tr><tr><td><code>F2</code></td><td>快速定位到错误代码</td></tr><tr><td><code>command+ alt + F7</code></td><td>查看哪些地方用到了指定的函数、类、方法</td></tr></tbody></table><blockquote><p><strong>说明</strong>：Windows系统下如果使用PyCharm的默认设置，可以将上面的<code>command</code>键换成<code>ctrl</code>键即可，唯一的例外是<code>ctrl + space</code>那个快捷键，因为它跟Windows系统切换输入法的快捷键是冲突的，所以在Windows系统下默认没有与之对应的快捷键。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python编程惯例</title>
      <link href="/2020/06/08/pythonic/python-bian-cheng-guan-li/"/>
      <url>/2020/06/08/pythonic/python-bian-cheng-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="Python编程惯例"><a href="#Python编程惯例" class="headerlink" title="Python编程惯例"></a>Python编程惯例</h2><p>“惯例”这个词指的是“习惯的做法，常规的办法，一贯的做法”，与这个词对应的英文单词叫“idiom”。由于Python跟其他很多编程语言在语法和使用上还是有比较显著的差别，因此作为一个Python开发者如果不能掌握这些惯例，就无法写出“Pythonic”的代码。下面我们总结了一些在Python开发中的惯用的代码。</p><ol><li><p>让代码既可以被导入又可以被执行。</p><pre class=" language-Python"><code class="language-Python">if __name__ == '__main__':</code></pre></li></ol><ol start="2"><li><p>用下面的方式判断逻辑“真”或“假”。</p><pre class=" language-Python"><code class="language-Python">if x:if not x:</code></pre><p><strong>好</strong>的代码：</p><pre class=" language-Python"><code class="language-Python">name = 'jackfrued'fruits = ['apple', 'orange', 'grape']owners = {'1001': '骆昊', '1002': '王大锤'}if name and fruits and owners:    print('I love fruits!')</code></pre><p><strong>不好</strong>的代码：</p><pre class=" language-Python"><code class="language-Python">name = 'jackfrued'fruits = ['apple', 'orange', 'grape']owners = {'1001': '骆昊', '1002': '王大锤'}if name != '' and len(fruits) > 0 and owners != {}:    print('I love fruits!')</code></pre></li><li><p>善于使用in运算符。</p><pre class=" language-Python"><code class="language-Python">if x in items: # 包含for x in items: # 迭代</code></pre><p><strong>好</strong>的代码：</p><pre class=" language-Python"><code class="language-Python">name = 'Hao LUO'if 'L' in name:    print('The name has an L in it.')</code></pre><p><strong>不好</strong>的代码：</p><pre class=" language-Python"><code class="language-Python">name = 'Hao LUO'if name.find('L') != -1:    print('This name has an L in it!')</code></pre></li><li><p>不使用临时变量交换两个值。</p><pre class=" language-Python"><code class="language-Python">a, b = b, a</code></pre></li><li><p>用序列构建字符串。</p><p><strong>好</strong>的代码：</p><pre class=" language-Python"><code class="language-Python">chars = ['j', 'a', 'c', 'k', 'f', 'r', 'u', 'e', 'd']name = ''.join(chars)print(name)  # jackfrued</code></pre><p><strong>不好</strong>的代码：</p><pre class=" language-Python"><code class="language-Python">chars = ['j', 'a', 'c', 'k', 'f', 'r', 'u', 'e', 'd']name = ''for char in chars:    name += charprint(name)  # jackfrued</code></pre></li><li><p>EAFP优于LBYL。</p><p>EAFP - <strong>E</strong>asier to <strong>A</strong>sk <strong>F</strong>orgiveness than <strong>P</strong>ermission.</p><p>LBYL - <strong>L</strong>ook <strong>B</strong>efore <strong>Y</strong>ou <strong>L</strong>eap.</p><p><strong>好</strong>的代码：</p><pre class=" language-Python"><code class="language-Python">d = {'x': '5'}try:    value = int(d['x'])    print(value)except (KeyError, TypeError, ValueError):    value = None</code></pre><p><strong>不好</strong>的代码：</p><pre class=" language-Python"><code class="language-Python">d = {'x': '5'}if 'x' in d and isinstance(d['x'], str) \        and d['x'].isdigit():    value = int(d['x'])    print(value)else:    value = None</code></pre></li><li><p>使用enumerate进行迭代。</p><p><strong>好</strong>的代码：</p><pre class=" language-Python"><code class="language-Python">fruits = ['orange', 'grape', 'pitaya', 'blueberry']for index, fruit in enumerate(fruits):    print(index, ':', fruit)</code></pre><p><strong>不好</strong>的代码：</p><pre class=" language-Python"><code class="language-Python">fruits = ['orange', 'grape', 'pitaya', 'blueberry']index = 0for fruit in fruits:    print(index, ':', fruit)    index += 1</code></pre></li><li><p>用生成式生成列表。</p><p><strong>好</strong>的代码：</p><pre class=" language-Python"><code class="language-Python">data = [7, 20, 3, 15, 11]result = [num * 3 for num in data if num > 10]print(result)  # [60, 45, 33]</code></pre><p><strong>不好</strong>的代码：</p><pre class=" language-Python"><code class="language-Python">data = [7, 20, 3, 15, 11]result = []for i in data:    if i > 10:        result.append(i * 3)print(result)  # [60, 45, 33]</code></pre></li><li><p>用zip组合键和值来创建字典。</p><p><strong>好</strong>的代码：</p><pre class=" language-Python"><code class="language-Python">keys = ['1001', '1002', '1003']values = ['骆昊', '王大锤', '白元芳']d = dict(zip(keys, values))print(d)</code></pre><p><strong>不好</strong>的代码：</p><pre class=" language-Python"><code class="language-Python">keys = ['1001', '1002', '1003']values = ['骆昊', '王大锤', '白元芳']d = {}for i, key in enumerate(keys):    d[key] = values[i]print(d)</code></pre></li></ol><blockquote><p><strong>说明</strong>：这篇文章的内容来自于网络，有兴趣的读者可以阅读<a href="http://safehammad.com/downloads/python-idioms-2014-01-16.pdf" target="_blank" rel="noopener">原文</a>。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Pythonic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用函数还是用复杂的表达式</title>
      <link href="/2020/06/04/python/yong-han-shu-huan-shi-yong-fu-za-de-biao-da-shi/"/>
      <url>/2020/06/04/python/yong-han-shu-huan-shi-yong-fu-za-de-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="用函数还是用复杂的表达式"><a href="#用函数还是用复杂的表达式" class="headerlink" title="用函数还是用复杂的表达式"></a>用函数还是用复杂的表达式</h2><p>Perl语言的原作者<em>Larry Wall</em>曾经说过，伟大的程序员都有三个优点：懒惰、暴躁和自负。乍一看这三个词语没有一个是褒义词，但在程序员的世界里，这三个词有不同的意义。首先，懒惰会促使程序员去写一些省事儿的程序来辅助自己或别人更好的完成工作，这样我们就无需做那些重复和繁琐的劳动；同理能够用3行代码解决的事情，我们也绝不会写出10行代码来。其次，暴躁会让程序员主动的去完成一些你还没有提出的工作，去优化自己的代码让它更有效率，能够3秒钟完成的任务，我们绝不能容忍1分钟的等待。最后，自负会促使程序员写出可靠无误的代码，我们写代码不是为了接受批评和指责，而是为了让其他人来膜拜。</p><p>那么接下来就有一个很有意思的问题值得探讨一下，我们需要一个程序从输入的三个数中找出最大的那个数。这个程序对任何会编程的人来说都是小菜一碟，甚至不会编程的人经过10分钟的学习也能搞定。下面是用来解决这个问题的Python代码。</p><pre class=" language-Python"><code class="language-Python">a = int(input('a = '))b = int(input('b = '))c = int(input('c = '))if a > b:    the_max = aelse:    the_max = bif c > the_max:    the_max = cprint('The max is:', the_max)</code></pre><p>但是我们刚才说了，程序员都是懒惰的，很多程序员都会使用三元条件运算符来改写上面的代码。</p><pre class=" language-Python"><code class="language-Python">a = int(input('a = '))b = int(input('b = '))c = int(input('c = '))the_max = a if a > b else bthe_max = c if c > the_max else the_maxprint('The max is:', the_max)</code></pre><p>需要说明的是，Python在2.5版本以前是没有上面代码第4行和第5行中使用的三元条件运算符的，究其原因是Guido van Rossum（Python之父）认为三元条件运算符并不能帮助 Python变得更加简洁，于是那些习惯了在C/C++或Java中使用三元条件运算符（在这些语言中，三元条件运算符也称为“Elvis运算符”，因为<code>?:</code>放在一起很像著名摇滚歌手猫王Elvis的大背头）的程序员试着用<code>and</code>和<code>or</code>运算符的短路特性来模拟出三元操作符，于是在那个年代，上面的代码是这样写的。</p><pre class=" language-Python"><code class="language-Python">a = int(input('a = '))b = int(input('b = '))c = int(input('c = '))the_max = a > b and a or bthe_max = c > the_max and c or the_maxprint('The max is:', the_max)</code></pre><p>但是这种做法在某些场景下是不能成立的，且看下面的代码。</p><pre class=" language-Python"><code class="language-Python">a = 0b = -100# 下面的代码本来预期输出a的值，结果却得到了b的值# 因为a的值0在进行逻辑运算时会被视为False来处理print(True and a or b)# print(a if True else b)</code></pre><p>所以在Python 2.5以后引入了三元条件运算符来避免上面的风险（上面代码被注释掉的最后一句话）。那么，问题又来了，上面的代码还可以写得更简短吗？答案是肯定的。</p><pre class=" language-Python"><code class="language-Python">a = int(input('a = '))b = int(input('b = '))c = int(input('c = '))print('The max is:', (a if a > b else b) if (a if a > b else b) > c else c)</code></pre><p>但是，这样做真的好吗？如此复杂的表达式是不是让代码变得晦涩了很多呢？我们发现，在实际开发中很多开发者都喜欢过度的使用某种语言的特性或语法糖，于是简单的多行代码变成了复杂的单行表达式，这样做真的好吗？这个问题我也不止一次的问过自己，现在我能给出的答案是下面的代码，使用辅助函数。</p><pre class=" language-Python"><code class="language-Python">def the_max(x, y):    return x if x > y else ya = int(input('a = '))b = int(input('b = '))c = int(input('c = '))print('The max is:', the_max(the_max(a, b), c))</code></pre><p>上面的代码中，我定义了一个辅助函数<code>the_max</code>用来找出参数传入的两个值中较大的那一个，于是下面的输出语句可以通过两次调用<code>the_max</code>函数来找出三个数中的最大值，现在代码的可读性是不是好了很多。用辅助函数来替代复杂的表达式真的是一个不错的选择，关键是比较大小的逻辑转移到这个辅助函数后不仅可以反复调用它，而且还可以进行级联操作。</p><p>当然，很多语言中比较大小的函数根本没有必要自己来实现（通常都是内置函数），Python也是如此。Python内置的max函数利用了Python对可变参数的支持，允许一次性传入多个值或者一个迭代器并找出那个最大值，所以上面讨论的问题在Python中也就是一句话的事，但是从复杂表达式到使用辅助函数简化复杂表达式这个思想是非常值得玩味的，所以分享出来跟大家做一个交流。</p><pre class=" language-Python"><code class="language-Python">a = int(input('a = '))b = int(input('b = '))c = int(input('c = '))print('The max is:', max(a, b, c))</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PEP 8风格指南</title>
      <link href="/2020/06/03/pythonic/pep8-feng-ge-zhi-nan/"/>
      <url>/2020/06/03/pythonic/pep8-feng-ge-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h2 id="PEP-8风格指南"><a href="#PEP-8风格指南" class="headerlink" title="PEP 8风格指南"></a>PEP 8风格指南</h2><p>PEP是Python Enhancement Proposal的缩写，通常翻译为“Python增强提案”。每个PEP都是一份为Python社区提供的指导Python往更好的方向发展的技术文档，其中的第8号增强提案（PEP 8）是针对Python语言编订的代码风格指南。尽管我们可以在保证语法没有问题的前提下随意书写Python代码，但是在实际开发中，采用一致的风格书写出可读性强的代码是每个专业的程序员应该做到的事情，也是每个公司的编程规范中会提出的要求，这些在多人协作开发一个项目（团队开发）的时候显得尤为重要。我们可以从Python官方网站的<a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP 8链接</a>中找到该文档，下面我们对该文档的关键部分做一个简单的总结。</p><h3 id="空格的使用"><a href="#空格的使用" class="headerlink" title="空格的使用"></a>空格的使用</h3><ol><li><u>使用空格来表示缩进而不要用制表符（Tab）。</u>这一点对习惯了其他编程语言的人来说简直觉得不可理喻，因为绝大多数的程序员都会用Tab来表示缩进，但是要知道Python并没有像C/C++或Java那样的用花括号来构造一个代码块的语法，在Python中分支和循环结构都使用缩进来表示哪些代码属于同一个级别，鉴于此Python代码对缩进以及缩进宽度的依赖比其他很多语言都强得多。在不同的编辑器中，Tab的宽度可能是2、4或8个字符，甚至是其他更离谱的值，用Tab来表示缩进对Python代码来说可能是一场灾难。</li><li><u>和语法相关的每一层缩进都用4个空格来表示。</u></li><li><u>每行的字符数不要超过79个字符，如果表达式因太长而占据了多行，除了首行之外的其余各行都应该在正常的缩进宽度上再加上4个空格。</u></li><li><u>函数和类的定义，代码前后都要用两个空行进行分隔。</u></li><li><u>在同一个类中，各个方法之间应该用一个空行进行分隔。</u></li><li><u>二元运算符的左右两侧应该保留一个空格，而且只要一个空格就好。</u></li></ol><h3 id="标识符命名"><a href="#标识符命名" class="headerlink" title="标识符命名"></a>标识符命名</h3><p>PEP 8倡导用不同的命名风格来命名Python中不同的标识符，以便在阅读代码时能够通过标识符的名称来确定该标识符在Python中扮演了怎样的角色（在这一点上，Python自己的内置模块以及某些第三方模块都做得并不是很好）。</p><ol><li><u>变量、函数和属性应该使用小写字母来拼写，如果有多个单词就使用下划线进行连接。</u></li><li><u>类中受保护的实例属性，应该以一个下划线开头。</u></li><li><u>类中私有的实例属性，应该以两个下划线开头。</u></li><li><u>类和异常的命名，应该每个单词首字母大写。</u></li><li><u>模块级别的常量，应该采用全大写字母，如果有多个单词就用下划线进行连接。</u></li><li><u>类的实例方法，应该把第一个参数命名为<code>self</code>以表示对象自身。</u></li><li><u>类的类方法，应该把第一个参数命名为<code>cls</code>以表示该类自身。</u></li></ol><h3 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h3><p>在Python之禅（可以使用<code>import this</code>查看）中有这么一句名言：“There should be one– and preferably only one –obvious way to do it.”，翻译成中文是“做一件事应该有而且最好只有一种确切的做法”，这句话传达的思想在PEP 8中也是无处不在的。</p><ol><li><u>采用内联形式的否定词，而不要把否定词放在整个表达式的前面。</u>例如<code>if a is not b</code>就比<code>if not a is b</code>更容易让人理解。</li><li>不要用检查长度的方式来判断字符串、列表等是否为<code>None</code>或者没有元素，应该用<code>if not x</code>这样的写法来检查它。</li><li><u>就算<code>if</code>分支、<code>for</code>循环、<code>except</code>异常捕获等中只有一行代码，也不要将代码和<code>if</code>、<code>for</code>、<code>except</code>等写在一起，分开写才会让代码更清晰。</u></li><li><u><code>import</code>语句总是放在文件开头的地方。</u></li><li><u>引入模块的时候，<code>from math import sqrt</code>比<code>import math</code>更好。</u></li><li><u>如果有多个<code>import</code>语句，应该将其分为三部分，从上到下分别是Python<strong>标准模块</strong>、<strong>第三方模块</strong>和<strong>自定义模块</strong>，每个部分内部应该按照模块名称的<strong>字母表顺序</strong>来排列。</u></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Pythonic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那些年我们踩过的那些坑</title>
      <link href="/2020/06/02/python/na-xie-nian-wo-men-cai-guo-de-na-xie-keng/"/>
      <url>/2020/06/02/python/na-xie-nian-wo-men-cai-guo-de-na-xie-keng/</url>
      
        <content type="html"><![CDATA[<h2 id="那些年我们踩过的那些坑"><a href="#那些年我们踩过的那些坑" class="headerlink" title="那些年我们踩过的那些坑"></a>那些年我们踩过的那些坑</h2><h3 id="坑1-整数比较的坑"><a href="#坑1-整数比较的坑" class="headerlink" title="坑1 - 整数比较的坑"></a>坑1 - 整数比较的坑</h3><p>在 Python 中一切都是对象，整数也是对象，在比较两个整数时有两个运算符<code>==</code>和<code>is</code>，它们的区别是：</p><ul><li><code>is</code>比较的是两个整数对象的id值是否相等，也就是比较两个引用是否代表了内存中同一个地址。</li><li><code>==</code>比较的是两个整数对象的内容是否相等，使用<code>==</code>时其实是调用了对象的<code>__eq__()</code>方法。</li></ul><p>知道了<code>is</code>和<code>==</code>的区别之后，我们可以来看看下面的代码，了解Python中整数比较有哪些坑，<strong>以CPython解释器为例</strong>，大家先看看下面的代码。</p><pre class=" language-Python"><code class="language-Python">def main():    x = y = -1    while True:        x += 1        y += 1        if x is y:            print('%d is %d' % (x, y))        else:            print('Attention! %d is not %d' % (x, y))            break    x = y = 0    while True:        x -= 1        y -= 1        if x is y:            print('%d is %d' % (x, y))        else:            print('Attention! %d is not %d' % (x, y))            breakif __name__ == '__main__':    main()</code></pre><p>上面代码的部分运行结果如下图所示。这个结果是因为CPython出于性能优化的考虑，把频繁使用的整数对象用一个叫<code>small_ints</code>的对象池缓存起来造成的。<code>small_ints</code>缓存的整数值被设定为<code>[-5, 256]</code>这个区间，也就是说，如果使用CPython解释器，在任何引用这些整数的地方，都不需要重新创建<code>int</code>对象，而是直接引用缓存池中的对象。如果整数不在该范围内，那么即便两个整数的值相同，它们也是不同的对象。</p><p>当然仅仅如此这个坑就不值一提了，如果你理解了上面的规则，我们就再看看下面的代码。</p><pre class=" language-Python"><code class="language-Python">a = 257def main():    b = 257  # 第6行    c = 257  # 第7行    print(b is c)  # True    print(a is b)  # False    print(a is c)  # Falseif __name__ == "__main__":    main()</code></pre><p>程序的执行结果已经用注释写在代码上了。够坑吧！看上去<code>a</code>、<code>b</code>和<code>c</code>的值都是一样的，但是<code>is</code>运算的结果却不一样。为什么会出现这样的结果，首先我们来说说Python程序中的代码块。所谓代码块是程序的一个最小的基本执行单位，一个模块文件、一个函数体、一个类、交互式命令中的单行代码都叫做一个代码块。上面的代码由两个代码块构成，<code>a = 257</code>是一个代码块，<code>main</code>函数是另外一个代码块。CPython底层为了进一步提升性能还做了一个设定：对于同一个代码块中值不在<code>small_ints</code>缓存范围之内的整数，如果同一个代码块中已经存在一个值与其相同的整数对象，那么就直接引用该对象，否则创建新的<code>int</code>对象。需要大家注意的是，这条规则对数值型适用，但对字符串则需要考虑字符串的长度，这一点可以自行证明。<br>为了验证刚刚的结论，我们可以借用<code>dis</code>模块（听名字就知道是进行反汇编的模块）从字节码的角度来看看这段代码。如果不理解什么是字节码，可以先看看<a href="(http://www.cnblogs.com/restran/p/4903056.html)">《谈谈 Python 程序的运行原理》</a>这篇文章。可以先用<code>import dis</code>导入<code>dis</code>模块并按照如下所示的方式修改代码。</p><pre class=" language-Python"><code class="language-Python">import disdis.dis(main)</code></pre><p>代码的执行结果如下图所示。可以看出代码第6行和第7行，也就是<code>main</code>函数中的257是从同一个位置加载的，因此是同一个对象；而代码第9行的<code>a</code>明显是从不同的地方加载的，因此引用的是不同的对象。</p><p>如果还想对这个问题进行进一步深挖，推荐大家阅读<a href="https://foofish.net/python_int_implement.html" target="_blank" rel="noopener">《Python整数对象实现原理》</a>这篇文章。</p><h3 id="坑2-嵌套列表的坑"><a href="#坑2-嵌套列表的坑" class="headerlink" title="坑2 - 嵌套列表的坑"></a>坑2 - 嵌套列表的坑</h3><p>Python中有一种内置的数据类型叫列表，它是一种容器，可以用来承载其他的对象（准确的说是其他对象的引用），列表中的对象可以称为列表的元素，很明显我们可以把列表作为列表中的元素，这就是所谓的嵌套列表。嵌套列表可以模拟出现实中的表格、矩阵、2D游戏的地图（如植物大战僵尸的花园）、棋盘（如国际象棋、黑白棋）等。但是在使用嵌套的列表时要小心，否则很可能遭遇非常尴尬的情况，下面是一个小例子。</p><pre class=" language-Python"><code class="language-Python">names = ['关羽', '张飞', '赵云', '马超', '黄忠']subjs = ['语文', '数学', '英语']scores = [[0] * 3] * 5for row, name in enumerate(names):    print('请输入%s的成绩' % name)    for col, subj in enumerate(subjs):        scores[row][col] = float(input(subj + ': '))        print(scores)</code></pre><p>我们希望录入5个学生3门课程的成绩，于是定义了一个有5个元素的列表，而列表中的每个元素又是一个由3个元素构成的列表，这样一个列表的列表刚好跟一个表格是一致的，相当于有5行3列，接下来我们通过嵌套的for-in循环输入每个学生3门课程的成绩。程序执行完成后我们发现，每个学生3门课程的成绩是一模一样的，而且就是最后录入的那个学生的成绩。</p><p>要想把这个坑填平，我们首先要区分对象和对象的引用这两个概念，而要区分这两个概念，还得先说说内存中的栈和堆。我们经常会听人说起“堆栈”这个词，但实际上“堆”和“栈”是两个不同的概念。众所周知，一个程序运行时需要占用一些内存空间来存储数据和代码，那么这些内存从逻辑上又可以做进一步的划分。对底层语言（如C语言）有所了解的程序员大都知道，程序中可以使用的内存从逻辑上可以为五个部分，按照地址从高到低依次是：栈（stack）、堆（heap）、数据段（data segment）、只读数据段（static area）和代码段（code segment）。其中，栈用来存储局部、临时变量，以及函数调用时保存现场和恢复现场需要用到的数据，这部分内存在代码块开始执行时自动分配，代码块执行结束时自动释放，通常由编译器自动管理；堆的大小不固定，可以动态的分配和回收，因此如果程序中有大量的数据需要处理，这些数据通常都放在堆上，如果堆空间没有正确的被释放会引发内存泄露的问题，而像Python、Java等编程语言都使用了垃圾回收机制来实现自动化的内存管理（自动回收不再使用的堆空间）。所以下面的代码中，变量<code>a</code>并不是真正的对象，它是对象的引用，相当于记录了对象在堆空间的地址，通过这个地址我们可以访问到对应的对象；同理，变量<code>b</code>是列表容器的引用，它引用了堆空间上的列表容器，而列表容器中并没有保存真正的对象，它保存的也仅仅是对象的引用。</p><pre class=" language-Python"><code class="language-Python">a = object()b = ['apple', 'pitaya', 'grape']</code></pre><p>知道了这一点，我们可以回过头看看刚才的程序，我们对列表进行<code>[[0] * 3] * 5</code>操作时，仅仅是将<code>[0, 0, 0]</code>这个列表的地址进行了复制，并没有创建新的列表对象，所以容器中虽然有5个元素，但是这5个元素引用了同一个列表对象，这一点可以通过<code>id</code>函数检查<code>scores[0]</code>和<code>scores[1]</code>的地址得到证实。所以正确的代码应该按照如下的方式进行修改。</p><pre class=" language-Python"><code class="language-Python">names = ['关羽', '张飞', '赵云', '马超', '黄忠']subjs = ['语文', '数学', '英语']scores = [[]] * 5for row, name in enumerate(names):    print('请输入%s的成绩' % name)    scores[row] = [0] * 3    for col, subj in enumerate(subjs):        scores[row][col] = float(input(subj + ': '))        print(scores)</code></pre><p>或者</p><pre class=" language-Python"><code class="language-Python">names = ['关羽', '张飞', '赵云', '马超', '黄忠']subjs = ['语文', '数学', '英语']scores = [[0] * 3 for _ in range(5)]for row, name in enumerate(names):    print('请输入%s的成绩' % name)    scores[row] = [0] * 3    for col, subj in enumerate(subjs):        scores[row][col] = float(input(subj + ': '))        print(scores)</code></pre><p>如果对内存的使用不是很理解，可以看看<a href="http://www.pythontutor.com/" target="_blank" rel="noopener">PythonTutor网站</a>上提供的代码可视化执行功能，通过可视化执行，我们可以看到内存是如何分配的，从而避免在使用嵌套列表或者复制对象时可能遇到的坑。</p><h3 id="坑3-访问修饰符的坑"><a href="#坑3-访问修饰符的坑" class="headerlink" title="坑3 - 访问修饰符的坑"></a>坑3 - 访问修饰符的坑</h3><p>用Python做过面向对象编程的人都知道，Python的类提供了两种访问控制权限，一种是公开，一种是私有（在属性或方法前加上双下划线）。而用惯了Java或C#这类编程语言的人都知道，类中的属性（数据抽象）通常都是私有的，其目的是为了将数据保护起来；而类中的方法（行为抽象）通常都是公开的，因为方法是对象向外界提供的服务。但是Python并没有从语法层面确保私有成员的私密性，因为它只是对类中所谓的私有成员进行了命名的变换，如果知道命名的规则照样可以直接访问私有成员，请看下面的代码。</p><pre class=" language-Python"><code class="language-Python">class Student(object):    def __init__(self, name, age):        self.__name = name        self.__age = age    def __str__(self):        return self.__name + ': ' + str(self.__age)stu = Student('lgq', 38)print(stu._Student__name)print(stu._Student__age)</code></pre><p>Python为什么要做出这样的设定呢？用一句广为流传的格言来解释这个问题：“We are all consenting adults here”（我们都是成年人）。这句话表达了很多Python程序员的一个共同观点，那就是开放比封闭要好，我们应该自己对自己的行为负责而不是从语言层面来限制对数据或方法的访问。</p><p>所以在Python中我们实在没有必要将类中的属性或方法用双下划线开头的命名处理成私有的成员，因为这并没有任何实际的意义。如果想对属性或方法进行保护，我们建议用单下划线开头的受保护成员，虽然它也不能真正保护这些属性或方法，但是它相当于给调用者一个暗示，让调用者知道这是不应该直接访问的属性或方法，而且这样做并不影响子类去继承这些东西。</p><p>需要提醒大家注意的是，Python类中的那些魔法方法，如<code>__str__</code>、<code>__repr__</code>等，这些方法并不是私有成员哦，虽然它们以双下划线开头，但是他们也是以双下划线结尾的，这种命名并不是私有成员的命名，这一点对初学者来说真的很坑。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo搭建自己的博客</title>
      <link href="/2020/04/05/web-kai-fa/shi-yong-hexo-da-jian-zi-ji-de-bo-ke/"/>
      <url>/2020/04/05/web-kai-fa/shi-yong-hexo-da-jian-zi-ji-de-bo-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="使用Hexo搭建自己的博客"><a href="#使用Hexo搭建自己的博客" class="headerlink" title="使用Hexo搭建自己的博客"></a>使用Hexo搭建自己的博客</h2><p>对于一个程序员来说，搭建一个属于自己的博客平台是非常有意义的事情。首先，博客可以记录自己的成长历程，也是对自己一段时间学习和工作的总结和沉淀；其他，通过博客可以营销自己，增强自己在互联网或行业内的影响力，为将来更好的职业生涯打一个坚实的基础。前几年有一本名为《软技能 - 代码之外的生存指南》的畅销书，我记得书中有这么一段话：“流行乐队的音乐才华可能并不比夜店驻场乐队高多少，他们为什么就可以在全世界巡回演出，创造一个又一个白金记录？……你的营销做得越好，你的才华才能表现得淋漓尽致。”</p><p>这里顺便啰嗦两句，在互联网如此发达的今天，我们应该如何营销自己呢？自我营销首先要从打造个人品牌做起，对于程序员来说，最容易去做好的一件事情还是搭建自己的博客。博客相当于是你在互联网上的一个基地，尤其是当你拥有了属于自己的独立博客后，你可以做很多自己想做的事情，既可以传达自己的思想，又可以提升自己的影响力，当然如果你的博客经营得非常好，你可以从中获利。当然，除了博客，直播、视频网站、投稿、写书、技术活动都是可选的自我营销方式。当然，做自我营销也需要持之以恒，三天打鱼两天晒网是很难有什么收获的。</p><h3 id="Hexo概述"><a href="#Hexo概述" class="headerlink" title="Hexo概述"></a>Hexo概述</h3><p>Hexo是一个快速、简洁且高效的博客框架，它能够将<a href="https://zh.wikipedia.org/zh-hans/Markdown" target="_blank" rel="noopener">Markdown格式</a>的文档渲染成漂亮的网页，这样我们就可以在很短的时间内迅速的创建出网站的静态内容，而Markdown格式对程序员来说相信并不陌生。要想使用Hexo来搭建自己的博客，我实在想不出有什么教程比<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">官方文档</a>更好，强烈建议大家阅读官方文档来了解Hexo，下面我只做一个简要的使用说明。</p><blockquote><p>说明：<strong>Markdown</strong>是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，同时也对图片、图表、数学公式提供了支持，可以用来书写电子书、软件文档等，同时也可以非常方便的转换为HTML页面或者是PDF文档。</p></blockquote><p>要使用Hexo，首先得确保计算机上已经安装了<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a>环境和<a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>环境，前者是一个能够在服务器端运行JavaScript代码的环境，后者是版本控制工具。安装node.js主要是为了使用它的包管理工具npm，所以不需要先系统的学习node.js的知识；而安装git是为了利用版本控制系统克隆代码已经将博客项目托管到三方平台，如果想学习git，最好的资料是官方网站上的<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener"><em>Git Pro</em></a>和<a href="http://www.worldhello.net/gotgit/index.html" target="_blank" rel="noopener">《Git权威指南》</a>。安装完成后，我们可以通过下面的命令来确认node.js环境以及它的包管理工具是否安装成功。</p><pre class=" language-Shell"><code class="language-Shell">node --versionnpm --version</code></pre><p>可以通过下面的命令来检查是否安装了git环境。</p><pre class=" language-Shell"><code class="language-Shell">git --version</code></pre><p>我们可以使用npm来安装Hexo，npm是node.js的包管理工具，跟Python的pip工具作用一样，可以用它来安装依赖库和三方工具。在第一次使用npm的时候，我们可以先将npm的下载源更换为国内的淘宝镜像，这样下载的速度会有非常显著的提升。</p><pre class=" language-Shell"><code class="language-Shell">npm config set registry https://registry.npm.taobao.org</code></pre><p>接下来我们就通过npm来安装Hexo，命令如下所示。</p><pre class=" language-Shell"><code class="language-Shell">npm install -g hexo-cli</code></pre><p>安装成功后，就可以使用Hexo来创建属于自己的博客啦。</p><h3 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h3><blockquote><p>说明：以下内容基本上来自于Hexo的官方文档，推荐大家阅读官方文档。</p></blockquote><p>我们先通过下面的命令来创建一个专门保存博客项目的文件夹，该命令会从github上克隆博客项目和默认的主题。</p><pre class=" language-Shell"><code class="language-Shell">hexo init blog</code></pre><p>接下来我们进入这个文件夹并查看目录结构。</p><pre class=" language-Shell"><code class="language-Shell">cd blogls -lR</code></pre><pre><code>total 232-rw-r--r--    1 Hao  staff    1768  8  8 01:15 _config.ymldrwxr-xr-x  274 Hao  staff    8768  8  8 01:19 node_modules-rw-r--r--    1 Hao  staff  109972  8  8 01:19 package-lock.json-rw-r--r--    1 Hao  staff     443  8  8 01:15 package.jsondrwxr-xr-x    5 Hao  staff     160  8  8 01:15 scaffoldsdrwxr-xr-x    3 Hao  staff      96  8  8 01:15 sourcedrwxr-xr-x    3 Hao  staff      96  8  8 01:15 themes</code></pre><blockquote><p>说明：Windows环境命令行提示符中可以使用dir命令查看目录结构。需要说明的是：<code>_config.yml</code>是博客项目的配置文件；<code>package.json</code>是项目的依赖项文件；<code>scaffolds</code>保存了Markdown文件的模板，也就是向新添加的Markdown文件中默认填充的内容；<code>source</code>目录下有一个名为<code>_post</code>的目录，我们稍后可以将编写好的Markdown文件放到该目录，这样就可以利用Hexo将Markdown文件处理成博客的静态页面，生成的静态页面将置于<code>public</code>目录下；<code>themes</code>文件夹保存了博客使用的主题。</p></blockquote><p>然后我们通过下面的命令来安装项目所需的依赖项（<code>package.json</code>文件指明了这些依赖项）。</p><pre class=" language-Shell"><code class="language-Shell">npm install</code></pre><p>做完上述的操作以后，我们已经可以直接通过下面的命令来生成博客。</p><pre class=" language-Shell"><code class="language-Shell">hexo generate</code></pre><p>该命令也可以缩写为：</p><pre class=" language-Shell"><code class="language-Shell">hexo g</code></pre><p>之前我们在安装依赖项的时候包括了一个名为<code>hexo-server</code>的依赖项，该依赖项可以帮助我们启动一个基于node.js的服务器来运行我们的博客项目，使用下面的命令即可启动服务器。</p><pre class=" language-Shell"><code class="language-Shell">hexo server</code></pre><p>该命令也可以缩写为：</p><pre class=" language-Shell"><code class="language-Shell">hexo s</code></pre><pre><code>INFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre><p>从运行命令的提示信息可以看到，服务器已经运转起并使用了4000端口，可以通过<code>Ctrl+C</code>来终止服务器的运行。如果要修改服务器使用的端口，可以在启动服务器的时候加上<code>-p</code>参数；如果希望服务器启动后，自动打开默认的浏览器访问服务器，可以使用<code>-o</code>参数，如下所示。</p><pre class=" language-Shell"><code class="language-Shell">hexo s -p 8000 -o</code></pre><p>接下来我们修改博客的配置文件。</p><pre class=" language-Shell"><code class="language-Shell">vim _config.yml</code></pre><pre class=" language-YAML"><code class="language-YAML"># Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Dream Come Truesubtitle: '不忘初心，方得始终'description: '只管把目标定在高峰，人家要笑就让他去笑'keywords:author: 丿梅川内库language: zh-CNtimezone: ''# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://1002178959.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight:  enable: true  line_number: true  auto_detect: false  tab_replace:# Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator:  path: ''  per_page: 10  order_by: -date# Category & Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type:</code></pre><p>下面是YAML文件中相关选项的说明。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>title</code></td><td>网站的标题</td></tr><tr><td><code>subtitle</code></td><td>网站的副标题</td></tr><tr><td><code>description</code></td><td>网站的描述</td></tr><tr><td><code>keywords</code></td><td>网站的关键词，可以用逗号分隔多个关键词</td></tr><tr><td><code>author</code></td><td>自己的名字</td></tr><tr><td><code>language</code></td><td>网站使用的语言</td></tr><tr><td><code>timezone</code></td><td>网站使用时区，默认使用电脑上设置的时区</td></tr><tr><td><code>url</code></td><td>网址</td></tr><tr><td><code>root</code></td><td>网站根目录</td></tr><tr><td><code>source_dir</code></td><td>资源文件夹，这个文件夹用来存放内容，默认source目录</td></tr><tr><td><code>public_dir</code></td><td>公共文件夹，这个文件夹用于存放生成的站点文件，默认public目录</td></tr><tr><td><code>tag_dir</code></td><td>标签文件夹，默认tags目录</td></tr><tr><td><code>archive_dir</code></td><td>归档文件夹，默认archives目录</td></tr><tr><td><code>category_dir</code></td><td>分类文件夹，默认categories目录</td></tr><tr><td><code>auto_spacing</code></td><td>在中文和英文之间加入空格，默认false</td></tr><tr><td><code>titlecase</code></td><td>把标题转换为首字母大写，默认false</td></tr><tr><td><code>external_link</code></td><td>在新标签中打开链接，默认true</td></tr><tr><td><code>relative_link</code></td><td>把链接改为与根目录的相对位址，默认false</td></tr><tr><td><code>default_category</code></td><td>默认分类</td></tr><tr><td><code>date_format</code></td><td>日期格式，默认YYYY-MM-DD</td></tr><tr><td><code>time_format</code></td><td>时间格式，默认HH:mm:ss</td></tr><tr><td><code>per_page</code></td><td>每页显示的文章数量 ，默认值10，0表示不使用分页</td></tr><tr><td><code>pagination_dir</code></td><td>分页目录，默认为page目录</td></tr><tr><td><code>theme</code></td><td>当前主题名称</td></tr><tr><td><code>deploy</code></td><td>部署部分的设置</td></tr></tbody></table><p>我们将编写好的Markdown文件可以拷贝到<code>source/_posts</code>目录，我们可以在每个Markdown文件的上方添加Front-matter来对文件的布局、标题、分类、标签、发布日期等信息加以说明。所谓Front-matter，就是每个Markdown文件最上方以<code>---</code>分隔的区域，可以在Front-matter中设置以下内容。</p><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>layout</code></td><td>布局</td><td></td></tr><tr><td><code>title</code></td><td>标题</td><td></td></tr><tr><td><code>date</code></td><td>建立日期</td><td>文件建立日期</td></tr><tr><td><code>updated</code></td><td>更新日期</td><td>文件更新日期</td></tr><tr><td><code>comments</code></td><td>开启文章的评论功能</td><td>true</td></tr><tr><td><code>tags</code></td><td>标签（不适用于分页）</td><td></td></tr><tr><td><code>categories</code></td><td>分类（不适用于分页）</td><td></td></tr><tr><td><code>permalink</code></td><td>覆盖文章网址</td><td></td></tr></tbody></table><p>例如：</p><pre class=" language-Markdown"><code class="language-Markdown">---title: Python编程惯例category: Python基础date: 2020-6-1---## Python惯例“惯例”这个词指的是“习惯的做法，常规的办法，一贯的做法”，与这个词对应的英文单词叫“idiom”。由于Python跟其他很多编程语言在语法和使用上还是有比较显著的差别，因此作为一个Python开发者如果不能掌握这些惯例，就无法写出“Pythonic”的代码。下面我们总结了一些在Python开发中的惯用的代码。1. 让代码既可以被导入又可以被执行。   if __name__ == '__main__':2. 用下面的方式判断逻辑“真”或“假”。   if x:   if not x:</code></pre><p>在完成上述工作后，我们可以通过下面的命令先清理之前生成的内容。</p><pre class=" language-Shell"><code class="language-Shell">hexo clean</code></pre><p>接下来我们就可以用之前讲过的命令重新生成并运行博客项目。</p><pre class=" language-Shell"><code class="language-Shell">hexo generatehexo server -p 8000 -o</code></pre><h3 id="将博客托管到GitHub"><a href="#将博客托管到GitHub" class="headerlink" title="将博客托管到GitHub"></a>将博客托管到GitHub</h3><p>我们可以利用GitHub网站提供的<a href="https://pages.github.com/" target="_blank" rel="noopener">Pages服务</a>来托管我们的博客。在GitHub Pages的首页上就有一个教程指导我们如何托管自己的网站，当然第一步得在GitHub上注册一个属于自己的账号，登录成功之后才能进行后续的操作。</p><ol><li>根据自己的用户名创建一个仓库，仓库<strong>一定</strong>要取名为“用户名.github.io”。例如：我在GitHub上的用户名是jackfrued，那么我的托管博客项目的仓库一定要命名为jackfrued.github.io。</li></ol><ol start="2"><li><p>修改博客项目的配置文件<code>_config.yml</code>，配置使用GitHub来部署该博客项目。</p><pre class=" language-Shell"><code class="language-Shell">vim _config.yml</code></pre><pre class=" language-YAML"><code class="language-YAML"># 省略上面的内容# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: https://github.com/1002178959/1002178959.github.io.git  branch: master</code></pre><p>上面的配置中，type指定了使用git进行项目部署，repo指定了部署项目的git仓库的URL，我们这里使用的是HTTPS的地址，如果之前配置过密钥对也可以使用SSH的地址，branch指定了将代码同步到仓库中的哪一个分支，通常master分支就是发布项目最终工作成果的分支，也称为项目的主分支。</p></li><li><p>安装名为<code>hexo-deployer-git</code>的部署器插件，通过该插件就能实现一键部署。</p><pre class=" language-Shell"><code class="language-Shell">npm install hexo-deployer-git --save</code></pre></li><li><p>可以使用下面的命令来实现一键部署到GitHub。</p><pre class=" language-Shell"><code class="language-Shell">hexo deploy -g</code></pre><p>或者</p><pre class=" language-Shell"><code class="language-Shell">hexo generate -d</code></pre></li><li><p>接下来在浏览器中输入<a href="https://github.com/1002178959/1002178959.github.io.git" target="_blank" rel="noopener">1002178959.github.io.git</a>就能够看到自己的博客，现在全世界的人都可以通过这个URL来访问你的博客。大家是否注意到，访问你博客的这个URL就是刚才我们给仓库起的名字，因为你在GitHub上注册的用户名是独一无二的，所以这个域名也是全世界独一无二的。</p></li></ol><h3 id="将博客绑定到自己的域名"><a href="#将博客绑定到自己的域名" class="headerlink" title="将博客绑定到自己的域名"></a>将博客绑定到自己的域名</h3><p>虽然我们已经通过GitHub提供的域名访问到了自己的博客，但是如果我们不愿意“寄人篱下”，我们在利用GitHub Pages提供的托管服务同时，也可以将博客绑定到自己专属的域名。如果暂时还没有购买域名，我们可以在提供域名购买服务的网站（如：<a href="https://www.hichina.com/" target="_blank" rel="noopener">万网</a>、<a href="https://www.godaddy.com/" target="_blank" rel="noopener">GoDaddy</a>）上进行购买。</p><blockquote><p>说明：目前国内对域名的管理日趋严格，在购买域名时需要填写一大堆的个人信息，进行实名认证后才能获得域名，这一点相信大家能够理解。</p></blockquote><p>比如说，我现在已经购买了一个名为“1002178959.top”的域名，如何让它跟“1002178959.github.io”这个域名做一个绑定呢，我们可以利用<a href="https://dns.console.aliyun.com/" target="_blank" rel="noopener">阿里云控制台</a>或者<a href="https://www.dnspod.cn/" target="_blank" rel="noopener">DNSPod</a>来做一个域名解析服务。在域名解析平台登录成功后，可以添加或选择自己的域名来配置域名解析。点击“添加记录”按钮，创建一个类型为CNAME的域名解析，CNAME类型的解析代表将一个域名解析到另一个域名。</p><p>完成这一步后，还不能马上通过自己的域名访问到博客项目，最后需要在博客项目的<code>source</code>目录下添加一个名为CNAME的文件（请注意这个文件的名字是全大写字母的）。</p><pre class=" language-Shell"><code class="language-Shell">vim CNAME</code></pre><p>编辑该文件的内容，如下所示。</p><pre><code>1002178959.top</code></pre><p>可以清理一下之前生成的内容，然后将项目重新生成并发布到GitHub就大功告成了！现在我们已经拥有了独立域名的博客，希望大家可以利用它做些有意义的事情（记录自己的成长历程、分享自己的工作经验、提升个人的影响力）。加油吧，程序员！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之禅</title>
      <link href="/2020/03/02/pythonic/python-zhi-shan/"/>
      <url>/2020/03/02/pythonic/python-zhi-shan/</url>
      
        <content type="html"><![CDATA[<h2 id="Zen-of-Python（Python之禅）"><a href="#Zen-of-Python（Python之禅）" class="headerlink" title="Zen of Python（Python之禅）"></a>Zen of Python（Python之禅）</h2><p>Beautiful is better than ugly. （优美比丑陋好）<br>Explicit is better than implicit.（清晰比晦涩好）<br>Simple is better than complex.（简单比复杂好）<br>Complex is better than complicated.（复杂比错综复杂好）<br>Flat is better than nested.（扁平比嵌套好）<br>Sparse is better than dense.（稀疏比密集好）<br>Readability counts.（可读性很重要）<br>Special cases aren’t special enough to break the rules.（特殊情况也不应该违反这些规则）<br>Although practicality beats purity.（但现实往往并不那么完美）<br>Errors should never pass silently.（异常不应该被静默处理）<br>Unless explicitly silenced.（除非你希望如此）<br>In the face of ambiguity, refuse the temptation to guess.（遇到模棱两可的地方，不要胡乱猜测）<br>There should be one– and preferably only one –obvious way to do it.（肯定有一种通常也是唯一一种最佳的解决方案）<br>Although that way may not be obvious at first unless you’re Dutch.（虽然这种方案并不是显而易见的，因为你不是那个荷兰人^这里指的是Python之父Guido^）<br>Now is better than never.（现在开始做比不做好）<br>Although never is often better than *right* now.（不做比盲目去做好^极限编程中的YAGNI原则^）<br>If the implementation is hard to explain, it’s a bad idea.（如果一个实现方案难于理解，它就不是一个好的方案）<br>If the implementation is easy to explain, it may be a good idea.（如果一个实现方案易于理解，它很有可能是一个好的方案）<br>Namespaces are one honking great idea – let’s do more of those!（命名空间非常有用，我们应当多加利用）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Pythonic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/10/21/hello-world/"/>
      <url>/2019/10/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python参考书籍</title>
      <link href="/2019/05/02/pythonic/python-can-kao-shu-ji/"/>
      <url>/2019/05/02/pythonic/python-can-kao-shu-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="Python参考书籍"><a href="#Python参考书籍" class="headerlink" title="Python参考书籍"></a>Python参考书籍</h2><h3 id="入门读物"><a href="#入门读物" class="headerlink" title="入门读物"></a>入门读物</h3><ol><li>《Python基础教程》（<em>Beginning Python From Novice to Professional</em>）</li><li>《Python学习手册》（<em>Learning Python</em>）</li><li>《Python编程》（<em>Programming Python</em>）</li><li>《Python Cookbook》</li><li>《Python程序设计》（<em>Python Programming: An Introduction to Computer Science</em>）</li><li>《Modern Python Cookbook》</li></ol><h3 id="进阶读物"><a href="#进阶读物" class="headerlink" title="进阶读物"></a>进阶读物</h3><ol><li>《Python核心编程》（<em>Core Python Applications Programming</em>）</li><li>《流畅的Python》（<em>Fluent Python</em>）</li><li>《Effective Python：编写高质量Python代码的59个有效方法》（<em>Effective Python 59 Specific Ways to Write Better Python</em>）</li><li>《Python设计模式》（<em>Learning Python Design Patterns</em>）</li><li>《Python高级编程》（<em>Expert Python Programming</em>）</li><li>《Python性能分析与优化》（<em>Mastering Python High Performance</em>）</li></ol><h3 id="Web框架"><a href="#Web框架" class="headerlink" title="Web框架"></a>Web框架</h3><ol><li>《Django基础教程》（<em>Tango with Django</em>）</li><li>《轻量级Django》（<em>Lightweight Django</em>）</li><li>《Python Web开发：测试驱动方法》（<em>Test-Driven Development with Python</em>）</li><li>《Web Development with Django Cookbook》</li><li>《Test-Driven Development with Django》</li><li>《Django Project Blueprints 》</li><li>《Flask Web开发：基于Python的Web应用开发实战》（<em>Flask Web Development: Developing Web Applications with Python</em>）</li><li>《深入理解Flask》（<em>Mastering Flask</em>）</li></ol><h3 id="爬虫开发"><a href="#爬虫开发" class="headerlink" title="爬虫开发"></a>爬虫开发</h3><ol><li>《用Python写网络爬虫》（<em>Web Scraping with Python</em>）</li><li>《精通Python爬虫框架Scrapy》（<em>Learning Scrapy</em>）</li><li>《Python网络数据采集》（<em>Web Scraping with Python</em>）</li><li>《Python爬虫开发与项目实战》</li><li>《Python 3网络爬虫开发实战》</li></ol><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><ol><li>《利用Python进行数据分析》（<em>Python for Data Analysis</em>）</li><li>《Python数据科学手册》（<em>Python Data Science Handbook</em>）</li><li>《Python金融大数据分析》（<em>Python for Finance</em>）</li><li>《Python数据可视化编程实战》（<em>Python Data Visualization Cookbook</em>）</li><li>《Python数据处理》（<em>Data Wrangling with Python</em>）</li></ol><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><ol><li>《Python机器学习基础教程》（<em>Introduction to Machine Learning with Python</em>）</li><li>《Python机器学习实践指南》（<em>Python Machine Learning Blueprints</em>）</li><li>《Python Machine Learning Case Studies》</li><li>《Python机器学习实践：测试驱动的开发方法》（<em>Thoughtful Machine Learning with Python A Test Driven Approach</em>）</li><li>《Python机器学习经典实例》（<em>Python Machine Learning Cookbook</em>）</li><li>《TensorFlow：实战Google深度学习框架》</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Pythonic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
